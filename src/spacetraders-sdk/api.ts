/* tslint:disable */
/* eslint-disable */
/**
 * SpaceTraders API
 * SpaceTraders is an open-universe game and learning platform that offers a set of HTTP endpoints to control a fleet of ships and explore a multiplayer universe.  The API is documented using [OpenAPI](https://github.com/SpaceTradersAPI/api-docs). You can send your first request right here in your browser to check the status of the game server.  ```json http {   \"method\": \"GET\",   \"url\": \"https://api.spacetraders.io/v2\", } ```  Unlike a traditional game, SpaceTraders does not have a first-party client or app to play the game. Instead, you can use the API to build your own client, write a script to automate your ships, or try an app built by the community.  We have a [Discord channel](https://discord.com/invite/jh6zurdWk5) where you can share your projects, ask questions, and get help from other players.   
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: joel@spacetraders.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AcceptContract200Response
 */
export interface AcceptContract200Response {
    /**
     * 
     * @type {AcceptContract200ResponseData}
     * @memberof AcceptContract200Response
     */
    'data': AcceptContract200ResponseData;
}
/**
 * 
 * @export
 * @interface AcceptContract200ResponseData
 */
export interface AcceptContract200ResponseData {
    /**
     * 
     * @type {Agent}
     * @memberof AcceptContract200ResponseData
     */
    'agent': Agent;
    /**
     * 
     * @type {Contract}
     * @memberof AcceptContract200ResponseData
     */
    'contract': Contract;
}
/**
 * 
 * @export
 * @interface Agent
 */
export interface Agent {
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    'symbol': string;
    /**
     * The headquarters of the agent.
     * @type {string}
     * @memberof Agent
     */
    'headquarters': string;
    /**
     * The number of credits the agent has available. Credits can be negative if funds have been overdrawn.
     * @type {number}
     * @memberof Agent
     */
    'credits': number;
    /**
     * The faction the agent started with.
     * @type {string}
     * @memberof Agent
     */
    'startingFaction': string;
}
/**
 * The chart of a system or waypoint, which makes the location visible to other agents.
 * @export
 * @interface Chart
 */
export interface Chart {
    /**
     * 
     * @type {string}
     * @memberof Chart
     */
    'waypointSymbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof Chart
     */
    'submittedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Chart
     */
    'submittedOn'?: string;
}
/**
 * 
 * @export
 * @interface ConnectedSystem
 */
export interface ConnectedSystem {
    /**
     * 
     * @type {string}
     * @memberof ConnectedSystem
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectedSystem
     */
    'sectorSymbol': string;
    /**
     * 
     * @type {SystemType}
     * @memberof ConnectedSystem
     */
    'type': SystemType;
    /**
     * The symbol of the faction that owns the connected jump gate in the system.
     * @type {string}
     * @memberof ConnectedSystem
     */
    'factionSymbol'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConnectedSystem
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof ConnectedSystem
     */
    'y': number;
    /**
     * 
     * @type {number}
     * @memberof ConnectedSystem
     */
    'distance': number;
}


/**
 * 
 * @export
 * @interface Contract
 */
export interface Contract {
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'id': string;
    /**
     * The symbol of the faction that this contract is for.
     * @type {string}
     * @memberof Contract
     */
    'factionSymbol': string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'type': ContractTypeEnum;
    /**
     * 
     * @type {ContractTerms}
     * @memberof Contract
     */
    'terms': ContractTerms;
    /**
     * Whether the contract has been accepted by the agent
     * @type {boolean}
     * @memberof Contract
     */
    'accepted': boolean;
    /**
     * Whether the contract has been fulfilled
     * @type {boolean}
     * @memberof Contract
     */
    'fulfilled': boolean;
    /**
     * Deprecated in favor of deadlineToAccept
     * @type {string}
     * @memberof Contract
     * @deprecated
     */
    'expiration': string;
    /**
     * The time at which the contract is no longer available to be accepted
     * @type {string}
     * @memberof Contract
     */
    'deadlineToAccept'?: string;
}

export const ContractTypeEnum = {
    Procurement: 'PROCUREMENT',
    Transport: 'TRANSPORT',
    Shuttle: 'SHUTTLE'
} as const;

export type ContractTypeEnum = typeof ContractTypeEnum[keyof typeof ContractTypeEnum];

/**
 * The details of a delivery contract. Includes the type of good, units needed, and the destination.
 * @export
 * @interface ContractDeliverGood
 */
export interface ContractDeliverGood {
    /**
     * The symbol of the trade good to deliver.
     * @type {string}
     * @memberof ContractDeliverGood
     */
    'tradeSymbol': string;
    /**
     * The destination where goods need to be delivered.
     * @type {string}
     * @memberof ContractDeliverGood
     */
    'destinationSymbol': string;
    /**
     * The number of units that need to be delivered on this contract.
     * @type {number}
     * @memberof ContractDeliverGood
     */
    'unitsRequired': number;
    /**
     * The number of units fulfilled on this contract.
     * @type {number}
     * @memberof ContractDeliverGood
     */
    'unitsFulfilled': number;
}
/**
 * 
 * @export
 * @interface ContractPayment
 */
export interface ContractPayment {
    /**
     * The amount of credits received up front for accepting the contract.
     * @type {number}
     * @memberof ContractPayment
     */
    'onAccepted': number;
    /**
     * The amount of credits received when the contract is fulfilled.
     * @type {number}
     * @memberof ContractPayment
     */
    'onFulfilled': number;
}
/**
 * 
 * @export
 * @interface ContractTerms
 */
export interface ContractTerms {
    /**
     * The deadline for the contract.
     * @type {string}
     * @memberof ContractTerms
     */
    'deadline': string;
    /**
     * 
     * @type {ContractPayment}
     * @memberof ContractTerms
     */
    'payment': ContractPayment;
    /**
     * 
     * @type {Array<ContractDeliverGood>}
     * @memberof ContractTerms
     */
    'deliver'?: Array<ContractDeliverGood>;
}
/**
 * A cooldown is a period of time in which a ship cannot perform certain actions.
 * @export
 * @interface Cooldown
 */
export interface Cooldown {
    /**
     * The symbol of the ship that is on cooldown
     * @type {string}
     * @memberof Cooldown
     */
    'shipSymbol': string;
    /**
     * The total duration of the cooldown in seconds
     * @type {number}
     * @memberof Cooldown
     */
    'totalSeconds': number;
    /**
     * The remaining duration of the cooldown in seconds
     * @type {number}
     * @memberof Cooldown
     */
    'remainingSeconds': number;
    /**
     * The date and time when the cooldown expires in ISO 8601 format
     * @type {string}
     * @memberof Cooldown
     */
    'expiration'?: string;
}
/**
 * 
 * @export
 * @interface CreateChart201Response
 */
export interface CreateChart201Response {
    /**
     * 
     * @type {CreateChart201ResponseData}
     * @memberof CreateChart201Response
     */
    'data': CreateChart201ResponseData;
}
/**
 * 
 * @export
 * @interface CreateChart201ResponseData
 */
export interface CreateChart201ResponseData {
    /**
     * 
     * @type {Chart}
     * @memberof CreateChart201ResponseData
     */
    'chart': Chart;
    /**
     * 
     * @type {Waypoint}
     * @memberof CreateChart201ResponseData
     */
    'waypoint': Waypoint;
}
/**
 * 
 * @export
 * @interface CreateShipShipScan201Response
 */
export interface CreateShipShipScan201Response {
    /**
     * 
     * @type {CreateShipShipScan201ResponseData}
     * @memberof CreateShipShipScan201Response
     */
    'data': CreateShipShipScan201ResponseData;
}
/**
 * 
 * @export
 * @interface CreateShipShipScan201ResponseData
 */
export interface CreateShipShipScan201ResponseData {
    /**
     * 
     * @type {Cooldown}
     * @memberof CreateShipShipScan201ResponseData
     */
    'cooldown': Cooldown;
    /**
     * 
     * @type {Array<ScannedShip>}
     * @memberof CreateShipShipScan201ResponseData
     */
    'ships': Array<ScannedShip>;
}
/**
 * 
 * @export
 * @interface CreateShipSystemScan201Response
 */
export interface CreateShipSystemScan201Response {
    /**
     * 
     * @type {CreateShipSystemScan201ResponseData}
     * @memberof CreateShipSystemScan201Response
     */
    'data': CreateShipSystemScan201ResponseData;
}
/**
 * 
 * @export
 * @interface CreateShipSystemScan201ResponseData
 */
export interface CreateShipSystemScan201ResponseData {
    /**
     * 
     * @type {Cooldown}
     * @memberof CreateShipSystemScan201ResponseData
     */
    'cooldown': Cooldown;
    /**
     * 
     * @type {Array<ScannedSystem>}
     * @memberof CreateShipSystemScan201ResponseData
     */
    'systems': Array<ScannedSystem>;
}
/**
 * 
 * @export
 * @interface CreateShipWaypointScan201Response
 */
export interface CreateShipWaypointScan201Response {
    /**
     * 
     * @type {CreateShipWaypointScan201ResponseData}
     * @memberof CreateShipWaypointScan201Response
     */
    'data': CreateShipWaypointScan201ResponseData;
}
/**
 * 
 * @export
 * @interface CreateShipWaypointScan201ResponseData
 */
export interface CreateShipWaypointScan201ResponseData {
    /**
     * 
     * @type {Cooldown}
     * @memberof CreateShipWaypointScan201ResponseData
     */
    'cooldown': Cooldown;
    /**
     * 
     * @type {Array<ScannedWaypoint>}
     * @memberof CreateShipWaypointScan201ResponseData
     */
    'waypoints': Array<ScannedWaypoint>;
}
/**
 * 
 * @export
 * @interface CreateSurvey201Response
 */
export interface CreateSurvey201Response {
    /**
     * 
     * @type {CreateSurvey201ResponseData}
     * @memberof CreateSurvey201Response
     */
    'data': CreateSurvey201ResponseData;
}
/**
 * 
 * @export
 * @interface CreateSurvey201ResponseData
 */
export interface CreateSurvey201ResponseData {
    /**
     * 
     * @type {Cooldown}
     * @memberof CreateSurvey201ResponseData
     */
    'cooldown': Cooldown;
    /**
     * 
     * @type {Array<Survey>}
     * @memberof CreateSurvey201ResponseData
     */
    'surveys': Array<Survey>;
}
/**
 * 
 * @export
 * @interface DeliverContract200Response
 */
export interface DeliverContract200Response {
    /**
     * 
     * @type {DeliverContract200ResponseData}
     * @memberof DeliverContract200Response
     */
    'data': DeliverContract200ResponseData;
}
/**
 * 
 * @export
 * @interface DeliverContract200ResponseData
 */
export interface DeliverContract200ResponseData {
    /**
     * 
     * @type {Contract}
     * @memberof DeliverContract200ResponseData
     */
    'contract': Contract;
    /**
     * 
     * @type {ShipCargo}
     * @memberof DeliverContract200ResponseData
     */
    'cargo': ShipCargo;
}
/**
 * 
 * @export
 * @interface DeliverContractRequest
 */
export interface DeliverContractRequest {
    /**
     * 
     * @type {string}
     * @memberof DeliverContractRequest
     */
    'shipSymbol': string;
    /**
     * 
     * @type {string}
     * @memberof DeliverContractRequest
     */
    'tradeSymbol': string;
    /**
     * 
     * @type {number}
     * @memberof DeliverContractRequest
     */
    'units': number;
}
/**
 * 
 * @export
 * @interface DockShip200Response
 */
export interface DockShip200Response {
    /**
     * 
     * @type {OrbitShip200ResponseData}
     * @memberof DockShip200Response
     */
    'data': OrbitShip200ResponseData;
}
/**
 * 
 * @export
 * @interface ExtractResources201Response
 */
export interface ExtractResources201Response {
    /**
     * 
     * @type {ExtractResources201ResponseData}
     * @memberof ExtractResources201Response
     */
    'data': ExtractResources201ResponseData;
}
/**
 * 
 * @export
 * @interface ExtractResources201ResponseData
 */
export interface ExtractResources201ResponseData {
    /**
     * 
     * @type {Cooldown}
     * @memberof ExtractResources201ResponseData
     */
    'cooldown': Cooldown;
    /**
     * 
     * @type {Extraction}
     * @memberof ExtractResources201ResponseData
     */
    'extraction': Extraction;
    /**
     * 
     * @type {ShipCargo}
     * @memberof ExtractResources201ResponseData
     */
    'cargo': ShipCargo;
}
/**
 * 
 * @export
 * @interface ExtractResourcesRequest
 */
export interface ExtractResourcesRequest {
    /**
     * 
     * @type {Survey}
     * @memberof ExtractResourcesRequest
     */
    'survey'?: Survey;
}
/**
 * 
 * @export
 * @interface Extraction
 */
export interface Extraction {
    /**
     * 
     * @type {string}
     * @memberof Extraction
     */
    'shipSymbol': string;
    /**
     * 
     * @type {ExtractionYield}
     * @memberof Extraction
     */
    'yield': ExtractionYield;
}
/**
 * 
 * @export
 * @interface ExtractionYield
 */
export interface ExtractionYield {
    /**
     * 
     * @type {string}
     * @memberof ExtractionYield
     */
    'symbol': string;
    /**
     * The number of units extracted that were placed into the ship\'s cargo hold.
     * @type {number}
     * @memberof ExtractionYield
     */
    'units': number;
}
/**
 * 
 * @export
 * @interface Faction
 */
export interface Faction {
    /**
     * 
     * @type {string}
     * @memberof Faction
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof Faction
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Faction
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Faction
     */
    'headquarters': string;
    /**
     * 
     * @type {Array<FactionTrait>}
     * @memberof Faction
     */
    'traits': Array<FactionTrait>;
    /**
     * Whether or not the faction is currently recruiting new agents.
     * @type {boolean}
     * @memberof Faction
     */
    'isRecruiting': boolean;
}
/**
 * 
 * @export
 * @interface FactionTrait
 */
export interface FactionTrait {
    /**
     * The unique identifier of the trait.
     * @type {string}
     * @memberof FactionTrait
     */
    'symbol': FactionTraitSymbolEnum;
    /**
     * The name of the trait.
     * @type {string}
     * @memberof FactionTrait
     */
    'name': string;
    /**
     * A description of the trait.
     * @type {string}
     * @memberof FactionTrait
     */
    'description': string;
}

export const FactionTraitSymbolEnum = {
    Bureaucratic: 'BUREAUCRATIC',
    Secretive: 'SECRETIVE',
    Capitalistic: 'CAPITALISTIC',
    Industrious: 'INDUSTRIOUS',
    Peaceful: 'PEACEFUL',
    Distrustful: 'DISTRUSTFUL',
    Welcoming: 'WELCOMING',
    Smugglers: 'SMUGGLERS',
    Scavengers: 'SCAVENGERS',
    Rebellious: 'REBELLIOUS',
    Exiles: 'EXILES',
    Pirates: 'PIRATES',
    Raiders: 'RAIDERS',
    Clan: 'CLAN',
    Guild: 'GUILD',
    Dominion: 'DOMINION',
    Fringe: 'FRINGE',
    Forsaken: 'FORSAKEN',
    Isolated: 'ISOLATED',
    Localized: 'LOCALIZED',
    Established: 'ESTABLISHED',
    Notable: 'NOTABLE',
    Dominant: 'DOMINANT',
    Inescapable: 'INESCAPABLE',
    Innovative: 'INNOVATIVE',
    Bold: 'BOLD',
    Visionary: 'VISIONARY',
    Curious: 'CURIOUS',
    Daring: 'DARING',
    Exploratory: 'EXPLORATORY',
    Resourceful: 'RESOURCEFUL',
    Flexible: 'FLEXIBLE',
    Cooperative: 'COOPERATIVE',
    United: 'UNITED',
    Strategic: 'STRATEGIC',
    Intelligent: 'INTELLIGENT',
    ResearchFocused: 'RESEARCH_FOCUSED',
    Collaborative: 'COLLABORATIVE',
    Progressive: 'PROGRESSIVE',
    Militaristic: 'MILITARISTIC',
    TechnologicallyAdvanced: 'TECHNOLOGICALLY_ADVANCED',
    Aggressive: 'AGGRESSIVE',
    Imperialistic: 'IMPERIALISTIC',
    TreasureHunters: 'TREASURE_HUNTERS',
    Dexterous: 'DEXTEROUS',
    Unpredictable: 'UNPREDICTABLE',
    Brutal: 'BRUTAL',
    Fleeting: 'FLEETING',
    Adaptable: 'ADAPTABLE',
    SelfSufficient: 'SELF_SUFFICIENT',
    Defensive: 'DEFENSIVE',
    Proud: 'PROUD',
    Diverse: 'DIVERSE',
    Independent: 'INDEPENDENT',
    SelfInterested: 'SELF_INTERESTED',
    Fragmented: 'FRAGMENTED',
    Commercial: 'COMMERCIAL',
    FreeMarkets: 'FREE_MARKETS',
    Entrepreneurial: 'ENTREPRENEURIAL'
} as const;

export type FactionTraitSymbolEnum = typeof FactionTraitSymbolEnum[keyof typeof FactionTraitSymbolEnum];

/**
 * 
 * @export
 * @interface FulfillContract200Response
 */
export interface FulfillContract200Response {
    /**
     * 
     * @type {AcceptContract200ResponseData}
     * @memberof FulfillContract200Response
     */
    'data': AcceptContract200ResponseData;
}
/**
 * 
 * @export
 * @interface GetContract200Response
 */
export interface GetContract200Response {
    /**
     * 
     * @type {Contract}
     * @memberof GetContract200Response
     */
    'data': Contract;
}
/**
 * 
 * @export
 * @interface GetContracts200Response
 */
export interface GetContracts200Response {
    /**
     * 
     * @type {Array<Contract>}
     * @memberof GetContracts200Response
     */
    'data': Array<Contract>;
    /**
     * 
     * @type {Meta}
     * @memberof GetContracts200Response
     */
    'meta': Meta;
}
/**
 * 
 * @export
 * @interface GetFaction200Response
 */
export interface GetFaction200Response {
    /**
     * 
     * @type {Faction}
     * @memberof GetFaction200Response
     */
    'data': Faction;
}
/**
 * 
 * @export
 * @interface GetFactions200Response
 */
export interface GetFactions200Response {
    /**
     * 
     * @type {Array<Faction>}
     * @memberof GetFactions200Response
     */
    'data': Array<Faction>;
    /**
     * 
     * @type {Meta}
     * @memberof GetFactions200Response
     */
    'meta': Meta;
}
/**
 * 
 * @export
 * @interface GetJumpGate200Response
 */
export interface GetJumpGate200Response {
    /**
     * 
     * @type {JumpGate}
     * @memberof GetJumpGate200Response
     */
    'data': JumpGate;
}
/**
 * 
 * @export
 * @interface GetMarket200Response
 */
export interface GetMarket200Response {
    /**
     * 
     * @type {Market}
     * @memberof GetMarket200Response
     */
    'data': Market;
}
/**
 * 
 * @export
 * @interface GetMounts200Response
 */
export interface GetMounts200Response {
    /**
     * 
     * @type {Array<ShipMount>}
     * @memberof GetMounts200Response
     */
    'data': Array<ShipMount>;
}
/**
 * 
 * @export
 * @interface GetMyAgent200Response
 */
export interface GetMyAgent200Response {
    /**
     * 
     * @type {Agent}
     * @memberof GetMyAgent200Response
     */
    'data': Agent;
}
/**
 * 
 * @export
 * @interface GetMyShip200Response
 */
export interface GetMyShip200Response {
    /**
     * 
     * @type {Ship}
     * @memberof GetMyShip200Response
     */
    'data': Ship;
}
/**
 * 
 * @export
 * @interface GetMyShipCargo200Response
 */
export interface GetMyShipCargo200Response {
    /**
     * 
     * @type {ShipCargo}
     * @memberof GetMyShipCargo200Response
     */
    'data': ShipCargo;
}
/**
 * 
 * @export
 * @interface GetMyShips200Response
 */
export interface GetMyShips200Response {
    /**
     * 
     * @type {Array<Ship>}
     * @memberof GetMyShips200Response
     */
    'data': Array<Ship>;
    /**
     * 
     * @type {Meta}
     * @memberof GetMyShips200Response
     */
    'meta': Meta;
}
/**
 * 
 * @export
 * @interface GetShipCooldown200Response
 */
export interface GetShipCooldown200Response {
    /**
     * 
     * @type {Cooldown}
     * @memberof GetShipCooldown200Response
     */
    'data': Cooldown;
}
/**
 * 
 * @export
 * @interface GetShipNav200Response
 */
export interface GetShipNav200Response {
    /**
     * 
     * @type {ShipNav}
     * @memberof GetShipNav200Response
     */
    'data': ShipNav;
}
/**
 * 
 * @export
 * @interface GetShipyard200Response
 */
export interface GetShipyard200Response {
    /**
     * 
     * @type {Shipyard}
     * @memberof GetShipyard200Response
     */
    'data': Shipyard;
}
/**
 * OK
 * @export
 * @interface GetStatus200Response
 */
export interface GetStatus200Response {
    /**
     * The current status of the game server.
     * @type {string}
     * @memberof GetStatus200Response
     */
    'status': string;
    /**
     * The current version of the API.
     * @type {string}
     * @memberof GetStatus200Response
     */
    'version': string;
    /**
     * The date and time when the game server was last reset.
     * @type {string}
     * @memberof GetStatus200Response
     */
    'resetDate': string;
    /**
     * 
     * @type {string}
     * @memberof GetStatus200Response
     */
    'description': string;
    /**
     * 
     * @type {GetStatus200ResponseStats}
     * @memberof GetStatus200Response
     */
    'stats': GetStatus200ResponseStats;
    /**
     * 
     * @type {GetStatus200ResponseLeaderboards}
     * @memberof GetStatus200Response
     */
    'leaderboards': GetStatus200ResponseLeaderboards;
    /**
     * 
     * @type {GetStatus200ResponseServerResets}
     * @memberof GetStatus200Response
     */
    'serverResets': GetStatus200ResponseServerResets;
    /**
     * 
     * @type {Array<GetStatus200ResponseAnnouncementsInner>}
     * @memberof GetStatus200Response
     */
    'announcements': Array<GetStatus200ResponseAnnouncementsInner>;
    /**
     * 
     * @type {Array<GetStatus200ResponseLinksInner>}
     * @memberof GetStatus200Response
     */
    'links': Array<GetStatus200ResponseLinksInner>;
}
/**
 * 
 * @export
 * @interface GetStatus200ResponseAnnouncementsInner
 */
export interface GetStatus200ResponseAnnouncementsInner {
    /**
     * 
     * @type {string}
     * @memberof GetStatus200ResponseAnnouncementsInner
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof GetStatus200ResponseAnnouncementsInner
     */
    'body': string;
}
/**
 * 
 * @export
 * @interface GetStatus200ResponseLeaderboards
 */
export interface GetStatus200ResponseLeaderboards {
    /**
     * 
     * @type {Array<GetStatus200ResponseLeaderboardsMostCreditsInner>}
     * @memberof GetStatus200ResponseLeaderboards
     */
    'mostCredits': Array<GetStatus200ResponseLeaderboardsMostCreditsInner>;
    /**
     * 
     * @type {Array<GetStatus200ResponseLeaderboardsMostSubmittedChartsInner>}
     * @memberof GetStatus200ResponseLeaderboards
     */
    'mostSubmittedCharts': Array<GetStatus200ResponseLeaderboardsMostSubmittedChartsInner>;
}
/**
 * 
 * @export
 * @interface GetStatus200ResponseLeaderboardsMostCreditsInner
 */
export interface GetStatus200ResponseLeaderboardsMostCreditsInner {
    /**
     * 
     * @type {string}
     * @memberof GetStatus200ResponseLeaderboardsMostCreditsInner
     */
    'agentSymbol': string;
    /**
     * 
     * @type {number}
     * @memberof GetStatus200ResponseLeaderboardsMostCreditsInner
     */
    'credits': number;
}
/**
 * 
 * @export
 * @interface GetStatus200ResponseLeaderboardsMostSubmittedChartsInner
 */
export interface GetStatus200ResponseLeaderboardsMostSubmittedChartsInner {
    /**
     * 
     * @type {string}
     * @memberof GetStatus200ResponseLeaderboardsMostSubmittedChartsInner
     */
    'agentSymbol': string;
    /**
     * 
     * @type {number}
     * @memberof GetStatus200ResponseLeaderboardsMostSubmittedChartsInner
     */
    'chartCount': number;
}
/**
 * 
 * @export
 * @interface GetStatus200ResponseLinksInner
 */
export interface GetStatus200ResponseLinksInner {
    /**
     * 
     * @type {string}
     * @memberof GetStatus200ResponseLinksInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetStatus200ResponseLinksInner
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface GetStatus200ResponseServerResets
 */
export interface GetStatus200ResponseServerResets {
    /**
     * The date and time when the game server will reset.
     * @type {string}
     * @memberof GetStatus200ResponseServerResets
     */
    'next': string;
    /**
     * How often we intend to reset the game server.
     * @type {string}
     * @memberof GetStatus200ResponseServerResets
     */
    'frequency': string;
}
/**
 * 
 * @export
 * @interface GetStatus200ResponseStats
 */
export interface GetStatus200ResponseStats {
    /**
     * 
     * @type {number}
     * @memberof GetStatus200ResponseStats
     */
    'agents': number;
    /**
     * 
     * @type {number}
     * @memberof GetStatus200ResponseStats
     */
    'ships': number;
    /**
     * 
     * @type {number}
     * @memberof GetStatus200ResponseStats
     */
    'systems': number;
    /**
     * 
     * @type {number}
     * @memberof GetStatus200ResponseStats
     */
    'waypoints': number;
}
/**
 * 
 * @export
 * @interface GetSystem200Response
 */
export interface GetSystem200Response {
    /**
     * 
     * @type {System}
     * @memberof GetSystem200Response
     */
    'data': System;
}
/**
 * 
 * @export
 * @interface GetSystemWaypoints200Response
 */
export interface GetSystemWaypoints200Response {
    /**
     * 
     * @type {Array<Waypoint>}
     * @memberof GetSystemWaypoints200Response
     */
    'data': Array<Waypoint>;
    /**
     * 
     * @type {Meta}
     * @memberof GetSystemWaypoints200Response
     */
    'meta': Meta;
}
/**
 * 
 * @export
 * @interface GetSystems200Response
 */
export interface GetSystems200Response {
    /**
     * 
     * @type {Array<System>}
     * @memberof GetSystems200Response
     */
    'data': Array<System>;
    /**
     * 
     * @type {Meta}
     * @memberof GetSystems200Response
     */
    'meta': Meta;
}
/**
 * 
 * @export
 * @interface GetWaypoint200Response
 */
export interface GetWaypoint200Response {
    /**
     * 
     * @type {Waypoint}
     * @memberof GetWaypoint200Response
     */
    'data': Waypoint;
}
/**
 * 
 * @export
 * @interface InstallMount201Response
 */
export interface InstallMount201Response {
    /**
     * 
     * @type {InstallMount201ResponseData}
     * @memberof InstallMount201Response
     */
    'data': InstallMount201ResponseData;
}
/**
 * 
 * @export
 * @interface InstallMount201ResponseData
 */
export interface InstallMount201ResponseData {
    /**
     * 
     * @type {Agent}
     * @memberof InstallMount201ResponseData
     */
    'agent': Agent;
    /**
     * 
     * @type {Array<ShipMount>}
     * @memberof InstallMount201ResponseData
     */
    'mounts': Array<ShipMount>;
    /**
     * 
     * @type {ShipCargo}
     * @memberof InstallMount201ResponseData
     */
    'cargo': ShipCargo;
    /**
     * 
     * @type {InstallMount201ResponseDataTransaction}
     * @memberof InstallMount201ResponseData
     */
    'transaction': InstallMount201ResponseDataTransaction;
}
/**
 * 
 * @export
 * @interface InstallMount201ResponseDataTransaction
 */
export interface InstallMount201ResponseDataTransaction {
    /**
     * The total price of the transaction.
     * @type {number}
     * @memberof InstallMount201ResponseDataTransaction
     */
    'totalPrice': number;
    /**
     * The timestamp of the transaction.
     * @type {string}
     * @memberof InstallMount201ResponseDataTransaction
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface InstallMountRequest
 */
export interface InstallMountRequest {
    /**
     * 
     * @type {string}
     * @memberof InstallMountRequest
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface Jettison200Response
 */
export interface Jettison200Response {
    /**
     * 
     * @type {Jettison200ResponseData}
     * @memberof Jettison200Response
     */
    'data': Jettison200ResponseData;
}
/**
 * 
 * @export
 * @interface Jettison200ResponseData
 */
export interface Jettison200ResponseData {
    /**
     * 
     * @type {ShipCargo}
     * @memberof Jettison200ResponseData
     */
    'cargo': ShipCargo;
}
/**
 * 
 * @export
 * @interface JettisonRequest
 */
export interface JettisonRequest {
    /**
     * 
     * @type {string}
     * @memberof JettisonRequest
     */
    'symbol': string;
    /**
     * 
     * @type {number}
     * @memberof JettisonRequest
     */
    'units': number;
}
/**
 * 
 * @export
 * @interface JumpGate
 */
export interface JumpGate {
    /**
     * The maximum jump range of the gate.
     * @type {number}
     * @memberof JumpGate
     */
    'jumpRange': number;
    /**
     * The symbol of the faction that owns the gate.
     * @type {string}
     * @memberof JumpGate
     */
    'factionSymbol'?: string;
    /**
     * The systems within range of the gate that have a corresponding gate.
     * @type {Array<ConnectedSystem>}
     * @memberof JumpGate
     */
    'connectedSystems': Array<ConnectedSystem>;
}
/**
 * 
 * @export
 * @interface JumpShip200Response
 */
export interface JumpShip200Response {
    /**
     * 
     * @type {JumpShip200ResponseData}
     * @memberof JumpShip200Response
     */
    'data': JumpShip200ResponseData;
}
/**
 * 
 * @export
 * @interface JumpShip200ResponseData
 */
export interface JumpShip200ResponseData {
    /**
     * 
     * @type {Cooldown}
     * @memberof JumpShip200ResponseData
     */
    'cooldown': Cooldown;
    /**
     * 
     * @type {ShipNav}
     * @memberof JumpShip200ResponseData
     */
    'nav'?: ShipNav;
}
/**
 * 
 * @export
 * @interface JumpShipRequest
 */
export interface JumpShipRequest {
    /**
     * The system symbol to jump to.
     * @type {string}
     * @memberof JumpShipRequest
     */
    'systemSymbol': string;
}
/**
 * 
 * @export
 * @interface Market
 */
export interface Market {
    /**
     * The symbol of the market. The symbol is the same as the waypoint where the market is located.
     * @type {string}
     * @memberof Market
     */
    'symbol': string;
    /**
     * The list of goods that are exported from this market.
     * @type {Array<TradeGood>}
     * @memberof Market
     */
    'exports': Array<TradeGood>;
    /**
     * The list of goods that are sought as imports in this market.
     * @type {Array<TradeGood>}
     * @memberof Market
     */
    'imports': Array<TradeGood>;
    /**
     * The list of goods that are bought and sold between agents at this market.
     * @type {Array<TradeGood>}
     * @memberof Market
     */
    'exchange': Array<TradeGood>;
    /**
     * The list of recent transactions at this market. Visible only when a ship is present at the market.
     * @type {Array<MarketTransaction>}
     * @memberof Market
     */
    'transactions'?: Array<MarketTransaction>;
    /**
     * The list of goods that are traded at this market. Visible only when a ship is present at the market.
     * @type {Array<MarketTradeGood>}
     * @memberof Market
     */
    'tradeGoods'?: Array<MarketTradeGood>;
}
/**
 * 
 * @export
 * @interface MarketTradeGood
 */
export interface MarketTradeGood {
    /**
     * The symbol of the trade good.
     * @type {string}
     * @memberof MarketTradeGood
     */
    'symbol': string;
    /**
     * The typical volume flowing through the market for this type of good. The larger the trade volume, the more stable prices will be.
     * @type {number}
     * @memberof MarketTradeGood
     */
    'tradeVolume': number;
    /**
     * A rough estimate of the total supply of this good in the marketplace.
     * @type {string}
     * @memberof MarketTradeGood
     */
    'supply': MarketTradeGoodSupplyEnum;
    /**
     * The price at which this good can be purchased from the market.
     * @type {number}
     * @memberof MarketTradeGood
     */
    'purchasePrice': number;
    /**
     * The price at which this good can be sold to the market.
     * @type {number}
     * @memberof MarketTradeGood
     */
    'sellPrice': number;
}

export const MarketTradeGoodSupplyEnum = {
    Scarce: 'SCARCE',
    Limited: 'LIMITED',
    Moderate: 'MODERATE',
    Abundant: 'ABUNDANT'
} as const;

export type MarketTradeGoodSupplyEnum = typeof MarketTradeGoodSupplyEnum[keyof typeof MarketTradeGoodSupplyEnum];

/**
 * 
 * @export
 * @interface MarketTransaction
 */
export interface MarketTransaction {
    /**
     * The symbol of the waypoint where the transaction took place.
     * @type {string}
     * @memberof MarketTransaction
     */
    'waypointSymbol': string;
    /**
     * The symbol of the ship that made the transaction.
     * @type {string}
     * @memberof MarketTransaction
     */
    'shipSymbol': string;
    /**
     * The symbol of the trade good.
     * @type {string}
     * @memberof MarketTransaction
     */
    'tradeSymbol': string;
    /**
     * The type of transaction.
     * @type {string}
     * @memberof MarketTransaction
     */
    'type': MarketTransactionTypeEnum;
    /**
     * The number of units of the transaction.
     * @type {number}
     * @memberof MarketTransaction
     */
    'units': number;
    /**
     * The price per unit of the transaction.
     * @type {number}
     * @memberof MarketTransaction
     */
    'pricePerUnit': number;
    /**
     * The total price of the transaction.
     * @type {number}
     * @memberof MarketTransaction
     */
    'totalPrice': number;
    /**
     * The timestamp of the transaction.
     * @type {string}
     * @memberof MarketTransaction
     */
    'timestamp': string;
}

export const MarketTransactionTypeEnum = {
    Purchase: 'PURCHASE',
    Sell: 'SELL'
} as const;

export type MarketTransactionTypeEnum = typeof MarketTransactionTypeEnum[keyof typeof MarketTransactionTypeEnum];

/**
 * 
 * @export
 * @interface Meta
 */
export interface Meta {
    /**
     * 
     * @type {number}
     * @memberof Meta
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof Meta
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof Meta
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface NavigateShip200Response
 */
export interface NavigateShip200Response {
    /**
     * 
     * @type {NavigateShip200ResponseData}
     * @memberof NavigateShip200Response
     */
    'data': NavigateShip200ResponseData;
}
/**
 * 
 * @export
 * @interface NavigateShip200ResponseData
 */
export interface NavigateShip200ResponseData {
    /**
     * 
     * @type {ShipFuel}
     * @memberof NavigateShip200ResponseData
     */
    'fuel': ShipFuel;
    /**
     * 
     * @type {ShipNav}
     * @memberof NavigateShip200ResponseData
     */
    'nav': ShipNav;
}
/**
 * 
 * @export
 * @interface NavigateShipRequest
 */
export interface NavigateShipRequest {
    /**
     * The target destination.
     * @type {string}
     * @memberof NavigateShipRequest
     */
    'waypointSymbol': string;
}
/**
 * 
 * @export
 * @interface NegotiateContract200Response
 */
export interface NegotiateContract200Response {
    /**
     * 
     * @type {NegotiateContract200ResponseData}
     * @memberof NegotiateContract200Response
     */
    'data': NegotiateContract200ResponseData;
}
/**
 * 
 * @export
 * @interface NegotiateContract200ResponseData
 */
export interface NegotiateContract200ResponseData {
    /**
     * 
     * @type {Contract}
     * @memberof NegotiateContract200ResponseData
     */
    'contract': Contract;
}
/**
 * 
 * @export
 * @interface OrbitShip200Response
 */
export interface OrbitShip200Response {
    /**
     * 
     * @type {OrbitShip200ResponseData}
     * @memberof OrbitShip200Response
     */
    'data': OrbitShip200ResponseData;
}
/**
 * 
 * @export
 * @interface OrbitShip200ResponseData
 */
export interface OrbitShip200ResponseData {
    /**
     * 
     * @type {ShipNav}
     * @memberof OrbitShip200ResponseData
     */
    'nav': ShipNav;
}
/**
 * 
 * @export
 * @interface PatchShipNavRequest
 */
export interface PatchShipNavRequest {
    /**
     * 
     * @type {ShipNavFlightMode}
     * @memberof PatchShipNavRequest
     */
    'flightMode'?: ShipNavFlightMode;
}


/**
 * 
 * @export
 * @interface PurchaseCargo201Response
 */
export interface PurchaseCargo201Response {
    /**
     * 
     * @type {SellCargo201ResponseData}
     * @memberof PurchaseCargo201Response
     */
    'data': SellCargo201ResponseData;
}
/**
 * 
 * @export
 * @interface PurchaseCargoRequest
 */
export interface PurchaseCargoRequest {
    /**
     * 
     * @type {string}
     * @memberof PurchaseCargoRequest
     */
    'symbol': string;
    /**
     * 
     * @type {number}
     * @memberof PurchaseCargoRequest
     */
    'units': number;
}
/**
 * 
 * @export
 * @interface PurchaseShip201Response
 */
export interface PurchaseShip201Response {
    /**
     * 
     * @type {PurchaseShip201ResponseData}
     * @memberof PurchaseShip201Response
     */
    'data': PurchaseShip201ResponseData;
}
/**
 * 
 * @export
 * @interface PurchaseShip201ResponseData
 */
export interface PurchaseShip201ResponseData {
    /**
     * 
     * @type {Agent}
     * @memberof PurchaseShip201ResponseData
     */
    'agent': Agent;
    /**
     * 
     * @type {Ship}
     * @memberof PurchaseShip201ResponseData
     */
    'ship': Ship;
    /**
     * 
     * @type {ShipyardTransaction}
     * @memberof PurchaseShip201ResponseData
     */
    'transaction': ShipyardTransaction;
}
/**
 * 
 * @export
 * @interface PurchaseShipRequest
 */
export interface PurchaseShipRequest {
    /**
     * 
     * @type {ShipType}
     * @memberof PurchaseShipRequest
     */
    'shipType': ShipType;
    /**
     * The symbol of the waypoint you want to purchase the ship at.
     * @type {string}
     * @memberof PurchaseShipRequest
     */
    'waypointSymbol': string;
}


/**
 * 
 * @export
 * @interface RefuelShip200Response
 */
export interface RefuelShip200Response {
    /**
     * 
     * @type {RefuelShip200ResponseData}
     * @memberof RefuelShip200Response
     */
    'data': RefuelShip200ResponseData;
}
/**
 * 
 * @export
 * @interface RefuelShip200ResponseData
 */
export interface RefuelShip200ResponseData {
    /**
     * 
     * @type {Agent}
     * @memberof RefuelShip200ResponseData
     */
    'agent': Agent;
    /**
     * 
     * @type {ShipFuel}
     * @memberof RefuelShip200ResponseData
     */
    'fuel': ShipFuel;
    /**
     * 
     * @type {MarketTransaction}
     * @memberof RefuelShip200ResponseData
     */
    'transaction': MarketTransaction;
}
/**
 * 
 * @export
 * @interface Register201Response
 */
export interface Register201Response {
    /**
     * 
     * @type {Register201ResponseData}
     * @memberof Register201Response
     */
    'data': Register201ResponseData;
}
/**
 * 
 * @export
 * @interface Register201ResponseData
 */
export interface Register201ResponseData {
    /**
     * 
     * @type {Agent}
     * @memberof Register201ResponseData
     */
    'agent': Agent;
    /**
     * 
     * @type {Contract}
     * @memberof Register201ResponseData
     */
    'contract': Contract;
    /**
     * 
     * @type {Faction}
     * @memberof Register201ResponseData
     */
    'faction': Faction;
    /**
     * 
     * @type {Ship}
     * @memberof Register201ResponseData
     */
    'ship': Ship;
    /**
     * A Bearer token for accessing secured API endpoints.
     * @type {string}
     * @memberof Register201ResponseData
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface RegisterRequest
 */
export interface RegisterRequest {
    /**
     * The faction you choose determines your headquarters.
     * @type {any}
     * @memberof RegisterRequest
     */
    'faction': any;
    /**
     * How other agents will see your ships and information.
     * @type {string}
     * @memberof RegisterRequest
     */
    'symbol': string;
    /**
     * Your email address. This is used if you reserved your call sign between resets.
     * @type {string}
     * @memberof RegisterRequest
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface RemoveMount201Response
 */
export interface RemoveMount201Response {
    /**
     * 
     * @type {InstallMount201ResponseData}
     * @memberof RemoveMount201Response
     */
    'data': InstallMount201ResponseData;
}
/**
 * 
 * @export
 * @interface RemoveMountRequest
 */
export interface RemoveMountRequest {
    /**
     * 
     * @type {string}
     * @memberof RemoveMountRequest
     */
    'symbol': string;
}
/**
 * The ship that was scanned. Details include information about the ship that could be detected by the scanner.
 * @export
 * @interface ScannedShip
 */
export interface ScannedShip {
    /**
     * The globally unique identifier of the ship.
     * @type {string}
     * @memberof ScannedShip
     */
    'symbol': string;
    /**
     * 
     * @type {ShipRegistration}
     * @memberof ScannedShip
     */
    'registration': ShipRegistration;
    /**
     * 
     * @type {ShipNav}
     * @memberof ScannedShip
     */
    'nav': ShipNav;
    /**
     * 
     * @type {ScannedShipFrame}
     * @memberof ScannedShip
     */
    'frame'?: ScannedShipFrame;
    /**
     * 
     * @type {ScannedShipReactor}
     * @memberof ScannedShip
     */
    'reactor'?: ScannedShipReactor;
    /**
     * 
     * @type {ScannedShipEngine}
     * @memberof ScannedShip
     */
    'engine': ScannedShipEngine;
    /**
     * 
     * @type {Array<ScannedShipMountsInner>}
     * @memberof ScannedShip
     */
    'mounts'?: Array<ScannedShipMountsInner>;
}
/**
 * The engine of the ship.
 * @export
 * @interface ScannedShipEngine
 */
export interface ScannedShipEngine {
    /**
     * 
     * @type {string}
     * @memberof ScannedShipEngine
     */
    'symbol': string;
}
/**
 * The frame of the ship.
 * @export
 * @interface ScannedShipFrame
 */
export interface ScannedShipFrame {
    /**
     * 
     * @type {string}
     * @memberof ScannedShipFrame
     */
    'symbol': string;
}
/**
 * A mount on the ship.
 * @export
 * @interface ScannedShipMountsInner
 */
export interface ScannedShipMountsInner {
    /**
     * 
     * @type {string}
     * @memberof ScannedShipMountsInner
     */
    'symbol': string;
}
/**
 * The reactor of the ship.
 * @export
 * @interface ScannedShipReactor
 */
export interface ScannedShipReactor {
    /**
     * 
     * @type {string}
     * @memberof ScannedShipReactor
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface ScannedSystem
 */
export interface ScannedSystem {
    /**
     * 
     * @type {string}
     * @memberof ScannedSystem
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof ScannedSystem
     */
    'sectorSymbol': string;
    /**
     * 
     * @type {SystemType}
     * @memberof ScannedSystem
     */
    'type': SystemType;
    /**
     * 
     * @type {number}
     * @memberof ScannedSystem
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof ScannedSystem
     */
    'y': number;
    /**
     * 
     * @type {number}
     * @memberof ScannedSystem
     */
    'distance': number;
}


/**
 * A waypoint is a location that ships can travel to such as a Planet, Moon or Space Station.
 * @export
 * @interface ScannedWaypoint
 */
export interface ScannedWaypoint {
    /**
     * 
     * @type {string}
     * @memberof ScannedWaypoint
     */
    'symbol': string;
    /**
     * 
     * @type {WaypointType}
     * @memberof ScannedWaypoint
     */
    'type': WaypointType;
    /**
     * 
     * @type {string}
     * @memberof ScannedWaypoint
     */
    'systemSymbol': string;
    /**
     * 
     * @type {number}
     * @memberof ScannedWaypoint
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof ScannedWaypoint
     */
    'y': number;
    /**
     * 
     * @type {Array<WaypointOrbital>}
     * @memberof ScannedWaypoint
     */
    'orbitals': Array<WaypointOrbital>;
    /**
     * 
     * @type {WaypointFaction}
     * @memberof ScannedWaypoint
     */
    'faction'?: WaypointFaction;
    /**
     * The traits of the waypoint.
     * @type {Array<WaypointTrait>}
     * @memberof ScannedWaypoint
     */
    'traits': Array<WaypointTrait>;
    /**
     * 
     * @type {Chart}
     * @memberof ScannedWaypoint
     */
    'chart'?: Chart;
}


/**
 * 
 * @export
 * @interface SellCargo201Response
 */
export interface SellCargo201Response {
    /**
     * 
     * @type {SellCargo201ResponseData}
     * @memberof SellCargo201Response
     */
    'data': SellCargo201ResponseData;
}
/**
 * 
 * @export
 * @interface SellCargo201ResponseData
 */
export interface SellCargo201ResponseData {
    /**
     * 
     * @type {Agent}
     * @memberof SellCargo201ResponseData
     */
    'agent': Agent;
    /**
     * 
     * @type {ShipCargo}
     * @memberof SellCargo201ResponseData
     */
    'cargo': ShipCargo;
    /**
     * 
     * @type {MarketTransaction}
     * @memberof SellCargo201ResponseData
     */
    'transaction': MarketTransaction;
}
/**
 * 
 * @export
 * @interface SellCargoRequest
 */
export interface SellCargoRequest {
    /**
     * 
     * @type {string}
     * @memberof SellCargoRequest
     */
    'symbol': string;
    /**
     * 
     * @type {number}
     * @memberof SellCargoRequest
     */
    'units': number;
}
/**
 * A ship
 * @export
 * @interface Ship
 */
export interface Ship {
    /**
     * The globally unique identifier of the ship in the following format: `[AGENT_SYMBOL]_[HEX_ID]`
     * @type {string}
     * @memberof Ship
     */
    'symbol': string;
    /**
     * 
     * @type {ShipRegistration}
     * @memberof Ship
     */
    'registration': ShipRegistration;
    /**
     * 
     * @type {ShipNav}
     * @memberof Ship
     */
    'nav': ShipNav;
    /**
     * 
     * @type {ShipCrew}
     * @memberof Ship
     */
    'crew': ShipCrew;
    /**
     * 
     * @type {ShipFrame}
     * @memberof Ship
     */
    'frame': ShipFrame;
    /**
     * 
     * @type {ShipReactor}
     * @memberof Ship
     */
    'reactor': ShipReactor;
    /**
     * 
     * @type {ShipEngine}
     * @memberof Ship
     */
    'engine': ShipEngine;
    /**
     * 
     * @type {Array<ShipModule>}
     * @memberof Ship
     */
    'modules': Array<ShipModule>;
    /**
     * 
     * @type {Array<ShipMount>}
     * @memberof Ship
     */
    'mounts': Array<ShipMount>;
    /**
     * 
     * @type {ShipCargo}
     * @memberof Ship
     */
    'cargo': ShipCargo;
    /**
     * 
     * @type {ShipFuel}
     * @memberof Ship
     */
    'fuel': ShipFuel;
}
/**
 * 
 * @export
 * @interface ShipCargo
 */
export interface ShipCargo {
    /**
     * The max number of items that can be stored in the cargo hold.
     * @type {number}
     * @memberof ShipCargo
     */
    'capacity': number;
    /**
     * The number of items currently stored in the cargo hold.
     * @type {number}
     * @memberof ShipCargo
     */
    'units': number;
    /**
     * The items currently in the cargo hold.
     * @type {Array<ShipCargoItem>}
     * @memberof ShipCargo
     */
    'inventory': Array<ShipCargoItem>;
}
/**
 * The type of cargo item and the number of units.
 * @export
 * @interface ShipCargoItem
 */
export interface ShipCargoItem {
    /**
     * The unique identifier of the cargo item type.
     * @type {string}
     * @memberof ShipCargoItem
     */
    'symbol': string;
    /**
     * The name of the cargo item type.
     * @type {string}
     * @memberof ShipCargoItem
     */
    'name': string;
    /**
     * The description of the cargo item type.
     * @type {string}
     * @memberof ShipCargoItem
     */
    'description': string;
    /**
     * The number of units of the cargo item.
     * @type {number}
     * @memberof ShipCargoItem
     */
    'units': number;
}
/**
 * The ship\'s crew service and maintain the ship\'s systems and equipment.
 * @export
 * @interface ShipCrew
 */
export interface ShipCrew {
    /**
     * The current number of crew members on the ship.
     * @type {number}
     * @memberof ShipCrew
     */
    'current': number;
    /**
     * The minimum number of crew members required to maintain the ship.
     * @type {number}
     * @memberof ShipCrew
     */
    'required': number;
    /**
     * The maximum number of crew members the ship can support.
     * @type {number}
     * @memberof ShipCrew
     */
    'capacity': number;
    /**
     * The rotation of crew shifts. A stricter shift improves the ship\'s performance. A more relaxed shift improves the crew\'s morale.
     * @type {string}
     * @memberof ShipCrew
     */
    'rotation': ShipCrewRotationEnum;
    /**
     * A rough measure of the crew\'s morale. A higher morale means the crew is happier and more productive. A lower morale means the ship is more prone to accidents.
     * @type {number}
     * @memberof ShipCrew
     */
    'morale': number;
    /**
     * The amount of credits per crew member paid per hour. Wages are paid when a ship docks at a civilized waypoint.
     * @type {number}
     * @memberof ShipCrew
     */
    'wages': number;
}

export const ShipCrewRotationEnum = {
    Strict: 'STRICT',
    Relaxed: 'RELAXED'
} as const;

export type ShipCrewRotationEnum = typeof ShipCrewRotationEnum[keyof typeof ShipCrewRotationEnum];

/**
 * The engine determines how quickly a ship travels between waypoints.
 * @export
 * @interface ShipEngine
 */
export interface ShipEngine {
    /**
     * 
     * @type {string}
     * @memberof ShipEngine
     */
    'symbol': ShipEngineSymbolEnum;
    /**
     * 
     * @type {string}
     * @memberof ShipEngine
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ShipEngine
     */
    'description': string;
    /**
     * Condition is a range of 0 to 100 where 0 is completely worn out and 100 is brand new.
     * @type {number}
     * @memberof ShipEngine
     */
    'condition'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShipEngine
     */
    'speed': number;
    /**
     * 
     * @type {ShipRequirements}
     * @memberof ShipEngine
     */
    'requirements': ShipRequirements;
}

export const ShipEngineSymbolEnum = {
    ImpulseDriveI: 'ENGINE_IMPULSE_DRIVE_I',
    IonDriveI: 'ENGINE_ION_DRIVE_I',
    IonDriveIi: 'ENGINE_ION_DRIVE_II',
    HyperDriveI: 'ENGINE_HYPER_DRIVE_I'
} as const;

export type ShipEngineSymbolEnum = typeof ShipEngineSymbolEnum[keyof typeof ShipEngineSymbolEnum];

/**
 * The frame of the ship. The frame determines the number of modules and mounting points of the ship, as well as base fuel capacity. As the condition of the frame takes more wear, the ship will become more sluggish and less maneuverable.
 * @export
 * @interface ShipFrame
 */
export interface ShipFrame {
    /**
     * 
     * @type {string}
     * @memberof ShipFrame
     */
    'symbol': ShipFrameSymbolEnum;
    /**
     * 
     * @type {string}
     * @memberof ShipFrame
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ShipFrame
     */
    'description': string;
    /**
     * Condition is a range of 0 to 100 where 0 is completely worn out and 100 is brand new.
     * @type {number}
     * @memberof ShipFrame
     */
    'condition'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShipFrame
     */
    'moduleSlots': number;
    /**
     * 
     * @type {number}
     * @memberof ShipFrame
     */
    'mountingPoints': number;
    /**
     * 
     * @type {number}
     * @memberof ShipFrame
     */
    'fuelCapacity': number;
    /**
     * 
     * @type {ShipRequirements}
     * @memberof ShipFrame
     */
    'requirements': ShipRequirements;
}

export const ShipFrameSymbolEnum = {
    Probe: 'FRAME_PROBE',
    Drone: 'FRAME_DRONE',
    Interceptor: 'FRAME_INTERCEPTOR',
    Racer: 'FRAME_RACER',
    Fighter: 'FRAME_FIGHTER',
    Frigate: 'FRAME_FRIGATE',
    Shuttle: 'FRAME_SHUTTLE',
    Explorer: 'FRAME_EXPLORER',
    Miner: 'FRAME_MINER',
    LightFreighter: 'FRAME_LIGHT_FREIGHTER',
    HeavyFreighter: 'FRAME_HEAVY_FREIGHTER',
    Transport: 'FRAME_TRANSPORT',
    Destroyer: 'FRAME_DESTROYER',
    Cruiser: 'FRAME_CRUISER',
    Carrier: 'FRAME_CARRIER'
} as const;

export type ShipFrameSymbolEnum = typeof ShipFrameSymbolEnum[keyof typeof ShipFrameSymbolEnum];

/**
 * Details of the ship\'s fuel tanks including how much fuel was consumed during the last transit or action.
 * @export
 * @interface ShipFuel
 */
export interface ShipFuel {
    /**
     * The current amount of fuel in the ship\'s tanks.
     * @type {number}
     * @memberof ShipFuel
     */
    'current': number;
    /**
     * The maximum amount of fuel the ship\'s tanks can hold.
     * @type {number}
     * @memberof ShipFuel
     */
    'capacity': number;
    /**
     * 
     * @type {ShipFuelConsumed}
     * @memberof ShipFuel
     */
    'consumed'?: ShipFuelConsumed;
}
/**
 * 
 * @export
 * @interface ShipFuelConsumed
 */
export interface ShipFuelConsumed {
    /**
     * The amount of fuel consumed by the most recent transit or action.
     * @type {number}
     * @memberof ShipFuelConsumed
     */
    'amount': number;
    /**
     * The time at which the fuel was consumed.
     * @type {string}
     * @memberof ShipFuelConsumed
     */
    'timestamp': string;
}
/**
 * A module can be installed in a ship and provides a set of capabilities such as storage space or quarters for crew. Module installations are permanent.
 * @export
 * @interface ShipModule
 */
export interface ShipModule {
    /**
     * 
     * @type {string}
     * @memberof ShipModule
     */
    'symbol': ShipModuleSymbolEnum;
    /**
     * 
     * @type {number}
     * @memberof ShipModule
     */
    'capacity'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShipModule
     */
    'range'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShipModule
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ShipModule
     */
    'description'?: string;
    /**
     * 
     * @type {ShipRequirements}
     * @memberof ShipModule
     */
    'requirements': ShipRequirements;
}

export const ShipModuleSymbolEnum = {
    MineralProcessorI: 'MODULE_MINERAL_PROCESSOR_I',
    CargoHoldI: 'MODULE_CARGO_HOLD_I',
    CrewQuartersI: 'MODULE_CREW_QUARTERS_I',
    EnvoyQuartersI: 'MODULE_ENVOY_QUARTERS_I',
    PassengerCabinI: 'MODULE_PASSENGER_CABIN_I',
    MicroRefineryI: 'MODULE_MICRO_REFINERY_I',
    OreRefineryI: 'MODULE_ORE_REFINERY_I',
    FuelRefineryI: 'MODULE_FUEL_REFINERY_I',
    ScienceLabI: 'MODULE_SCIENCE_LAB_I',
    JumpDriveI: 'MODULE_JUMP_DRIVE_I',
    JumpDriveIi: 'MODULE_JUMP_DRIVE_II',
    JumpDriveIii: 'MODULE_JUMP_DRIVE_III',
    WarpDriveI: 'MODULE_WARP_DRIVE_I',
    WarpDriveIi: 'MODULE_WARP_DRIVE_II',
    WarpDriveIii: 'MODULE_WARP_DRIVE_III',
    ShieldGeneratorI: 'MODULE_SHIELD_GENERATOR_I',
    ShieldGeneratorIi: 'MODULE_SHIELD_GENERATOR_II'
} as const;

export type ShipModuleSymbolEnum = typeof ShipModuleSymbolEnum[keyof typeof ShipModuleSymbolEnum];

/**
 * A mount is installed on the exterier of a ship.
 * @export
 * @interface ShipMount
 */
export interface ShipMount {
    /**
     * 
     * @type {string}
     * @memberof ShipMount
     */
    'symbol': ShipMountSymbolEnum;
    /**
     * 
     * @type {string}
     * @memberof ShipMount
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ShipMount
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof ShipMount
     */
    'strength'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShipMount
     */
    'deposits'?: Array<ShipMountDepositsEnum>;
    /**
     * 
     * @type {ShipRequirements}
     * @memberof ShipMount
     */
    'requirements': ShipRequirements;
}

export const ShipMountSymbolEnum = {
    GasSiphonI: 'MOUNT_GAS_SIPHON_I',
    GasSiphonIi: 'MOUNT_GAS_SIPHON_II',
    GasSiphonIii: 'MOUNT_GAS_SIPHON_III',
    SurveyorI: 'MOUNT_SURVEYOR_I',
    SurveyorIi: 'MOUNT_SURVEYOR_II',
    SurveyorIii: 'MOUNT_SURVEYOR_III',
    SensorArrayI: 'MOUNT_SENSOR_ARRAY_I',
    SensorArrayIi: 'MOUNT_SENSOR_ARRAY_II',
    SensorArrayIii: 'MOUNT_SENSOR_ARRAY_III',
    MiningLaserI: 'MOUNT_MINING_LASER_I',
    MiningLaserIi: 'MOUNT_MINING_LASER_II',
    MiningLaserIii: 'MOUNT_MINING_LASER_III',
    LaserCannonI: 'MOUNT_LASER_CANNON_I',
    MissileLauncherI: 'MOUNT_MISSILE_LAUNCHER_I',
    TurretI: 'MOUNT_TURRET_I'
} as const;

export type ShipMountSymbolEnum = typeof ShipMountSymbolEnum[keyof typeof ShipMountSymbolEnum];
export const ShipMountDepositsEnum = {
    QuartzSand: 'QUARTZ_SAND',
    SiliconCrystals: 'SILICON_CRYSTALS',
    PreciousStones: 'PRECIOUS_STONES',
    IceWater: 'ICE_WATER',
    AmmoniaIce: 'AMMONIA_ICE',
    IronOre: 'IRON_ORE',
    CopperOre: 'COPPER_ORE',
    SilverOre: 'SILVER_ORE',
    AluminumOre: 'ALUMINUM_ORE',
    GoldOre: 'GOLD_ORE',
    PlatinumOre: 'PLATINUM_ORE',
    Diamonds: 'DIAMONDS',
    UraniteOre: 'URANITE_ORE',
    MeritiumOre: 'MERITIUM_ORE'
} as const;

export type ShipMountDepositsEnum = typeof ShipMountDepositsEnum[keyof typeof ShipMountDepositsEnum];

/**
 * The navigation information of the ship.
 * @export
 * @interface ShipNav
 */
export interface ShipNav {
    /**
     * The system symbol of the ship\'s current location.
     * @type {string}
     * @memberof ShipNav
     */
    'systemSymbol': string;
    /**
     * The waypoint symbol of the ship\'s current location, or if the ship is in-transit, the waypoint symbol of the ship\'s destination.
     * @type {string}
     * @memberof ShipNav
     */
    'waypointSymbol': string;
    /**
     * 
     * @type {ShipNavRoute}
     * @memberof ShipNav
     */
    'route': ShipNavRoute;
    /**
     * 
     * @type {ShipNavStatus}
     * @memberof ShipNav
     */
    'status': ShipNavStatus;
    /**
     * 
     * @type {ShipNavFlightMode}
     * @memberof ShipNav
     */
    'flightMode': ShipNavFlightMode;
}


/**
 * The ship\'s set speed when traveling between waypoints or systems.
 * @export
 * @enum {string}
 */

export const ShipNavFlightMode = {
    Drift: 'DRIFT',
    Stealth: 'STEALTH',
    Cruise: 'CRUISE',
    Burn: 'BURN'
} as const;

export type ShipNavFlightMode = typeof ShipNavFlightMode[keyof typeof ShipNavFlightMode];


/**
 * The routing information for the ship\'s most recent transit or current location.
 * @export
 * @interface ShipNavRoute
 */
export interface ShipNavRoute {
    /**
     * 
     * @type {ShipNavRouteWaypoint}
     * @memberof ShipNavRoute
     */
    'destination': ShipNavRouteWaypoint;
    /**
     * 
     * @type {ShipNavRouteWaypoint}
     * @memberof ShipNavRoute
     */
    'departure': ShipNavRouteWaypoint;
    /**
     * The date time of the ship\'s departure.
     * @type {string}
     * @memberof ShipNavRoute
     */
    'departureTime': string;
    /**
     * The date time of the ship\'s arrival. If the ship is in-transit, this is the expected time of arrival.
     * @type {string}
     * @memberof ShipNavRoute
     */
    'arrival': string;
}
/**
 * The destination or departure of a ships nav route.
 * @export
 * @interface ShipNavRouteWaypoint
 */
export interface ShipNavRouteWaypoint {
    /**
     * 
     * @type {string}
     * @memberof ShipNavRouteWaypoint
     */
    'symbol': string;
    /**
     * 
     * @type {WaypointType}
     * @memberof ShipNavRouteWaypoint
     */
    'type': WaypointType;
    /**
     * 
     * @type {string}
     * @memberof ShipNavRouteWaypoint
     */
    'systemSymbol': string;
    /**
     * 
     * @type {number}
     * @memberof ShipNavRouteWaypoint
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof ShipNavRouteWaypoint
     */
    'y': number;
}


/**
 * The current status of the ship
 * @export
 * @enum {string}
 */

export const ShipNavStatus = {
    InTransit: 'IN_TRANSIT',
    InOrbit: 'IN_ORBIT',
    Docked: 'DOCKED'
} as const;

export type ShipNavStatus = typeof ShipNavStatus[keyof typeof ShipNavStatus];


/**
 * The reactor of the ship. The reactor is responsible for powering the ship\'s systems and weapons.
 * @export
 * @interface ShipReactor
 */
export interface ShipReactor {
    /**
     * 
     * @type {string}
     * @memberof ShipReactor
     */
    'symbol': ShipReactorSymbolEnum;
    /**
     * 
     * @type {string}
     * @memberof ShipReactor
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ShipReactor
     */
    'description': string;
    /**
     * Condition is a range of 0 to 100 where 0 is completely worn out and 100 is brand new.
     * @type {number}
     * @memberof ShipReactor
     */
    'condition'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShipReactor
     */
    'powerOutput': number;
    /**
     * 
     * @type {ShipRequirements}
     * @memberof ShipReactor
     */
    'requirements': ShipRequirements;
}

export const ShipReactorSymbolEnum = {
    SolarI: 'REACTOR_SOLAR_I',
    FusionI: 'REACTOR_FUSION_I',
    FissionI: 'REACTOR_FISSION_I',
    ChemicalI: 'REACTOR_CHEMICAL_I',
    AntimatterI: 'REACTOR_ANTIMATTER_I'
} as const;

export type ShipReactorSymbolEnum = typeof ShipReactorSymbolEnum[keyof typeof ShipReactorSymbolEnum];

/**
 * 
 * @export
 * @interface ShipRefine200Response
 */
export interface ShipRefine200Response {
    /**
     * 
     * @type {ShipRefine200ResponseData}
     * @memberof ShipRefine200Response
     */
    'data': ShipRefine200ResponseData;
}
/**
 * 
 * @export
 * @interface ShipRefine200ResponseData
 */
export interface ShipRefine200ResponseData {
    /**
     * 
     * @type {ShipCargo}
     * @memberof ShipRefine200ResponseData
     */
    'cargo': ShipCargo;
    /**
     * 
     * @type {Cooldown}
     * @memberof ShipRefine200ResponseData
     */
    'cooldown': Cooldown;
    /**
     * 
     * @type {Array<ShipRefine200ResponseDataProducedInner>}
     * @memberof ShipRefine200ResponseData
     */
    'produced': Array<ShipRefine200ResponseDataProducedInner>;
    /**
     * 
     * @type {Array<ShipRefine200ResponseDataProducedInner>}
     * @memberof ShipRefine200ResponseData
     */
    'consumed': Array<ShipRefine200ResponseDataProducedInner>;
}
/**
 * 
 * @export
 * @interface ShipRefine200ResponseDataProducedInner
 */
export interface ShipRefine200ResponseDataProducedInner {
    /**
     * 
     * @type {string}
     * @memberof ShipRefine200ResponseDataProducedInner
     */
    'tradeSymbol'?: string;
    /**
     * 
     * @type {number}
     * @memberof ShipRefine200ResponseDataProducedInner
     */
    'units'?: number;
}
/**
 * 
 * @export
 * @interface ShipRefineRequest
 */
export interface ShipRefineRequest {
    /**
     * 
     * @type {string}
     * @memberof ShipRefineRequest
     */
    'produce': ShipRefineRequestProduceEnum;
}

export const ShipRefineRequestProduceEnum = {
    Iron: 'IRON',
    Copper: 'COPPER',
    Silver: 'SILVER',
    Gold: 'GOLD',
    Aluminum: 'ALUMINUM',
    Platinum: 'PLATINUM',
    Uranite: 'URANITE',
    Meritium: 'MERITIUM',
    Fuel: 'FUEL'
} as const;

export type ShipRefineRequestProduceEnum = typeof ShipRefineRequestProduceEnum[keyof typeof ShipRefineRequestProduceEnum];

/**
 * The public registration information of the ship
 * @export
 * @interface ShipRegistration
 */
export interface ShipRegistration {
    /**
     * The agent\'s registered name of the ship
     * @type {string}
     * @memberof ShipRegistration
     */
    'name': string;
    /**
     * The symbol of the faction the ship is registered with
     * @type {string}
     * @memberof ShipRegistration
     */
    'factionSymbol': string;
    /**
     * 
     * @type {ShipRole}
     * @memberof ShipRegistration
     */
    'role': ShipRole;
}


/**
 * The requirements for installation on a ship
 * @export
 * @interface ShipRequirements
 */
export interface ShipRequirements {
    /**
     * The amount of power required from the reactor.
     * @type {number}
     * @memberof ShipRequirements
     */
    'power'?: number;
    /**
     * The number of crew required for operation.
     * @type {number}
     * @memberof ShipRequirements
     */
    'crew'?: number;
    /**
     * The number of module slots required for installation.
     * @type {number}
     * @memberof ShipRequirements
     */
    'slots'?: number;
}
/**
 * The registered role of the ship
 * @export
 * @enum {string}
 */

export const ShipRole = {
    Fabricator: 'FABRICATOR',
    Harvester: 'HARVESTER',
    Hauler: 'HAULER',
    Interceptor: 'INTERCEPTOR',
    Excavator: 'EXCAVATOR',
    Transport: 'TRANSPORT',
    Repair: 'REPAIR',
    Surveyor: 'SURVEYOR',
    Command: 'COMMAND',
    Carrier: 'CARRIER',
    Patrol: 'PATROL',
    Satellite: 'SATELLITE',
    Explorer: 'EXPLORER',
    Refinery: 'REFINERY'
} as const;

export type ShipRole = typeof ShipRole[keyof typeof ShipRole];


/**
 * 
 * @export
 * @enum {string}
 */

export const ShipType = {
    Probe: 'SHIP_PROBE',
    MiningDrone: 'SHIP_MINING_DRONE',
    Interceptor: 'SHIP_INTERCEPTOR',
    LightHauler: 'SHIP_LIGHT_HAULER',
    CommandFrigate: 'SHIP_COMMAND_FRIGATE',
    Explorer: 'SHIP_EXPLORER',
    HeavyFreighter: 'SHIP_HEAVY_FREIGHTER',
    LightShuttle: 'SHIP_LIGHT_SHUTTLE',
    OreHound: 'SHIP_ORE_HOUND',
    RefiningFreighter: 'SHIP_REFINING_FREIGHTER'
} as const;

export type ShipType = typeof ShipType[keyof typeof ShipType];


/**
 * 
 * @export
 * @interface Shipyard
 */
export interface Shipyard {
    /**
     * The symbol of the shipyard. The symbol is the same as the waypoint where the shipyard is located.
     * @type {string}
     * @memberof Shipyard
     */
    'symbol': string;
    /**
     * The list of ship types available for purchase at this shipyard.
     * @type {Array<ShipyardShipTypesInner>}
     * @memberof Shipyard
     */
    'shipTypes': Array<ShipyardShipTypesInner>;
    /**
     * The list of recent transactions at this shipyard.
     * @type {Array<ShipyardTransaction>}
     * @memberof Shipyard
     */
    'transactions'?: Array<ShipyardTransaction>;
    /**
     * The ships that are currently available for purchase at the shipyard.
     * @type {Array<ShipyardShip>}
     * @memberof Shipyard
     */
    'ships'?: Array<ShipyardShip>;
}
/**
 * 
 * @export
 * @interface ShipyardShip
 */
export interface ShipyardShip {
    /**
     * 
     * @type {ShipType}
     * @memberof ShipyardShip
     */
    'type'?: ShipType;
    /**
     * 
     * @type {string}
     * @memberof ShipyardShip
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ShipyardShip
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof ShipyardShip
     */
    'purchasePrice': number;
    /**
     * 
     * @type {ShipFrame}
     * @memberof ShipyardShip
     */
    'frame': ShipFrame;
    /**
     * 
     * @type {ShipReactor}
     * @memberof ShipyardShip
     */
    'reactor': ShipReactor;
    /**
     * 
     * @type {ShipEngine}
     * @memberof ShipyardShip
     */
    'engine': ShipEngine;
    /**
     * 
     * @type {Array<ShipModule>}
     * @memberof ShipyardShip
     */
    'modules': Array<ShipModule>;
    /**
     * 
     * @type {Array<ShipMount>}
     * @memberof ShipyardShip
     */
    'mounts': Array<ShipMount>;
}


/**
 * 
 * @export
 * @interface ShipyardShipTypesInner
 */
export interface ShipyardShipTypesInner {
    /**
     * 
     * @type {ShipType}
     * @memberof ShipyardShipTypesInner
     */
    'type'?: ShipType;
}


/**
 * 
 * @export
 * @interface ShipyardTransaction
 */
export interface ShipyardTransaction {
    /**
     * The symbol of the waypoint where the transaction took place.
     * @type {string}
     * @memberof ShipyardTransaction
     */
    'waypointSymbol': string;
    /**
     * The symbol of the ship that was purchased.
     * @type {string}
     * @memberof ShipyardTransaction
     */
    'shipSymbol': string;
    /**
     * The price of the transaction.
     * @type {number}
     * @memberof ShipyardTransaction
     */
    'price': number;
    /**
     * The symbol of the agent that made the transaction.
     * @type {string}
     * @memberof ShipyardTransaction
     */
    'agentSymbol': string;
    /**
     * The timestamp of the transaction.
     * @type {string}
     * @memberof ShipyardTransaction
     */
    'timestamp': string;
}
/**
 * A resource survey of a waypoint, detailing a specific extraction location and the types of resources that can be found there.
 * @export
 * @interface Survey
 */
export interface Survey {
    /**
     * A unique signature for the location of this survey. This signature is verified when attempting an extraction using this survey.
     * @type {string}
     * @memberof Survey
     */
    'signature': string;
    /**
     * The symbol of the waypoint that this survey is for.
     * @type {string}
     * @memberof Survey
     */
    'symbol': string;
    /**
     * A list of deposits that can be found at this location.
     * @type {Array<SurveyDeposit>}
     * @memberof Survey
     */
    'deposits': Array<SurveyDeposit>;
    /**
     * The date and time when the survey expires. After this date and time, the survey will no longer be available for extraction.
     * @type {string}
     * @memberof Survey
     */
    'expiration': string;
    /**
     * The size of the deposit. This value indicates how much can be extracted from the survey before it is exhausted.
     * @type {string}
     * @memberof Survey
     */
    'size': SurveySizeEnum;
}

export const SurveySizeEnum = {
    Small: 'SMALL',
    Moderate: 'MODERATE',
    Large: 'LARGE'
} as const;

export type SurveySizeEnum = typeof SurveySizeEnum[keyof typeof SurveySizeEnum];

/**
 * A surveyed deposit of a mineral or resource available for extraction.
 * @export
 * @interface SurveyDeposit
 */
export interface SurveyDeposit {
    /**
     * The symbol of the deposit.
     * @type {string}
     * @memberof SurveyDeposit
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface System
 */
export interface System {
    /**
     * 
     * @type {string}
     * @memberof System
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof System
     */
    'sectorSymbol': string;
    /**
     * 
     * @type {SystemType}
     * @memberof System
     */
    'type': SystemType;
    /**
     * 
     * @type {number}
     * @memberof System
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof System
     */
    'y': number;
    /**
     * 
     * @type {Array<SystemWaypoint>}
     * @memberof System
     */
    'waypoints': Array<SystemWaypoint>;
    /**
     * 
     * @type {Array<SystemFaction>}
     * @memberof System
     */
    'factions': Array<SystemFaction>;
}


/**
 * 
 * @export
 * @interface SystemFaction
 */
export interface SystemFaction {
    /**
     * 
     * @type {string}
     * @memberof SystemFaction
     */
    'symbol': string;
}
/**
 * The type of waypoint.
 * @export
 * @enum {string}
 */

export const SystemType = {
    NeutronStar: 'NEUTRON_STAR',
    RedStar: 'RED_STAR',
    OrangeStar: 'ORANGE_STAR',
    BlueStar: 'BLUE_STAR',
    YoungStar: 'YOUNG_STAR',
    WhiteDwarf: 'WHITE_DWARF',
    BlackHole: 'BLACK_HOLE',
    Hypergiant: 'HYPERGIANT',
    Nebula: 'NEBULA',
    Unstable: 'UNSTABLE'
} as const;

export type SystemType = typeof SystemType[keyof typeof SystemType];


/**
 * 
 * @export
 * @interface SystemWaypoint
 */
export interface SystemWaypoint {
    /**
     * 
     * @type {string}
     * @memberof SystemWaypoint
     */
    'symbol': string;
    /**
     * 
     * @type {WaypointType}
     * @memberof SystemWaypoint
     */
    'type': WaypointType;
    /**
     * 
     * @type {number}
     * @memberof SystemWaypoint
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof SystemWaypoint
     */
    'y': number;
}


/**
 * 
 * @export
 * @interface TradeGood
 */
export interface TradeGood {
    /**
     * 
     * @type {TradeSymbol}
     * @memberof TradeGood
     */
    'symbol': TradeSymbol;
    /**
     * 
     * @type {string}
     * @memberof TradeGood
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TradeGood
     */
    'description': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TradeSymbol = {
    PreciousStones: 'PRECIOUS_STONES',
    QuartzSand: 'QUARTZ_SAND',
    SiliconCrystals: 'SILICON_CRYSTALS',
    AmmoniaIce: 'AMMONIA_ICE',
    LiquidHydrogen: 'LIQUID_HYDROGEN',
    LiquidNitrogen: 'LIQUID_NITROGEN',
    IceWater: 'ICE_WATER',
    ExoticMatter: 'EXOTIC_MATTER',
    AdvancedCircuitry: 'ADVANCED_CIRCUITRY',
    GravitonEmitters: 'GRAVITON_EMITTERS',
    Iron: 'IRON',
    IronOre: 'IRON_ORE',
    Copper: 'COPPER',
    CopperOre: 'COPPER_ORE',
    Aluminum: 'ALUMINUM',
    AluminumOre: 'ALUMINUM_ORE',
    Silver: 'SILVER',
    SilverOre: 'SILVER_ORE',
    Gold: 'GOLD',
    GoldOre: 'GOLD_ORE',
    Platinum: 'PLATINUM',
    PlatinumOre: 'PLATINUM_ORE',
    Diamonds: 'DIAMONDS',
    Uranite: 'URANITE',
    UraniteOre: 'URANITE_ORE',
    Meritium: 'MERITIUM',
    MeritiumOre: 'MERITIUM_ORE',
    Hydrocarbon: 'HYDROCARBON',
    Antimatter: 'ANTIMATTER',
    Fertilizers: 'FERTILIZERS',
    Fabrics: 'FABRICS',
    Food: 'FOOD',
    Jewelry: 'JEWELRY',
    Machinery: 'MACHINERY',
    Firearms: 'FIREARMS',
    AssaultRifles: 'ASSAULT_RIFLES',
    MilitaryEquipment: 'MILITARY_EQUIPMENT',
    Explosives: 'EXPLOSIVES',
    LabInstruments: 'LAB_INSTRUMENTS',
    Ammunition: 'AMMUNITION',
    Electronics: 'ELECTRONICS',
    ShipPlating: 'SHIP_PLATING',
    Equipment: 'EQUIPMENT',
    Fuel: 'FUEL',
    Medicine: 'MEDICINE',
    Drugs: 'DRUGS',
    Clothing: 'CLOTHING',
    Microprocessors: 'MICROPROCESSORS',
    Plastics: 'PLASTICS',
    Polynucleotides: 'POLYNUCLEOTIDES',
    Biocomposites: 'BIOCOMPOSITES',
    Nanobots: 'NANOBOTS',
    AiMainframes: 'AI_MAINFRAMES',
    QuantumDrives: 'QUANTUM_DRIVES',
    RoboticDrones: 'ROBOTIC_DRONES',
    CyberImplants: 'CYBER_IMPLANTS',
    GeneTherapeutics: 'GENE_THERAPEUTICS',
    NeuralChips: 'NEURAL_CHIPS',
    MoodRegulators: 'MOOD_REGULATORS',
    ViralAgents: 'VIRAL_AGENTS',
    MicroFusionGenerators: 'MICRO_FUSION_GENERATORS',
    Supergrains: 'SUPERGRAINS',
    LaserRifles: 'LASER_RIFLES',
    Holographics: 'HOLOGRAPHICS',
    ShipSalvage: 'SHIP_SALVAGE',
    RelicTech: 'RELIC_TECH',
    NovelLifeforms: 'NOVEL_LIFEFORMS',
    BotanicalSpecimens: 'BOTANICAL_SPECIMENS',
    CulturalArtifacts: 'CULTURAL_ARTIFACTS',
    ReactorSolarI: 'REACTOR_SOLAR_I',
    ReactorFusionI: 'REACTOR_FUSION_I',
    ReactorFissionI: 'REACTOR_FISSION_I',
    ReactorChemicalI: 'REACTOR_CHEMICAL_I',
    ReactorAntimatterI: 'REACTOR_ANTIMATTER_I',
    EngineImpulseDriveI: 'ENGINE_IMPULSE_DRIVE_I',
    EngineIonDriveI: 'ENGINE_ION_DRIVE_I',
    EngineIonDriveIi: 'ENGINE_ION_DRIVE_II',
    EngineHyperDriveI: 'ENGINE_HYPER_DRIVE_I',
    ModuleMineralProcessorI: 'MODULE_MINERAL_PROCESSOR_I',
    ModuleCargoHoldI: 'MODULE_CARGO_HOLD_I',
    ModuleCrewQuartersI: 'MODULE_CREW_QUARTERS_I',
    ModuleEnvoyQuartersI: 'MODULE_ENVOY_QUARTERS_I',
    ModulePassengerCabinI: 'MODULE_PASSENGER_CABIN_I',
    ModuleMicroRefineryI: 'MODULE_MICRO_REFINERY_I',
    ModuleOreRefineryI: 'MODULE_ORE_REFINERY_I',
    ModuleFuelRefineryI: 'MODULE_FUEL_REFINERY_I',
    ModuleScienceLabI: 'MODULE_SCIENCE_LAB_I',
    ModuleJumpDriveI: 'MODULE_JUMP_DRIVE_I',
    ModuleJumpDriveIi: 'MODULE_JUMP_DRIVE_II',
    ModuleJumpDriveIii: 'MODULE_JUMP_DRIVE_III',
    ModuleWarpDriveI: 'MODULE_WARP_DRIVE_I',
    ModuleWarpDriveIi: 'MODULE_WARP_DRIVE_II',
    ModuleWarpDriveIii: 'MODULE_WARP_DRIVE_III',
    ModuleShieldGeneratorI: 'MODULE_SHIELD_GENERATOR_I',
    ModuleShieldGeneratorIi: 'MODULE_SHIELD_GENERATOR_II',
    MountGasSiphonI: 'MOUNT_GAS_SIPHON_I',
    MountGasSiphonIi: 'MOUNT_GAS_SIPHON_II',
    MountGasSiphonIii: 'MOUNT_GAS_SIPHON_III',
    MountSurveyorI: 'MOUNT_SURVEYOR_I',
    MountSurveyorIi: 'MOUNT_SURVEYOR_II',
    MountSurveyorIii: 'MOUNT_SURVEYOR_III',
    MountSensorArrayI: 'MOUNT_SENSOR_ARRAY_I',
    MountSensorArrayIi: 'MOUNT_SENSOR_ARRAY_II',
    MountSensorArrayIii: 'MOUNT_SENSOR_ARRAY_III',
    MountMiningLaserI: 'MOUNT_MINING_LASER_I',
    MountMiningLaserIi: 'MOUNT_MINING_LASER_II',
    MountMiningLaserIii: 'MOUNT_MINING_LASER_III',
    MountLaserCannonI: 'MOUNT_LASER_CANNON_I',
    MountMissileLauncherI: 'MOUNT_MISSILE_LAUNCHER_I',
    MountTurretI: 'MOUNT_TURRET_I'
} as const;

export type TradeSymbol = typeof TradeSymbol[keyof typeof TradeSymbol];


/**
 * 
 * @export
 * @interface TransferCargo200Response
 */
export interface TransferCargo200Response {
    /**
     * 
     * @type {Jettison200ResponseData}
     * @memberof TransferCargo200Response
     */
    'data': Jettison200ResponseData;
}
/**
 * 
 * @export
 * @interface TransferCargoRequest
 */
export interface TransferCargoRequest {
    /**
     * 
     * @type {string}
     * @memberof TransferCargoRequest
     */
    'tradeSymbol': string;
    /**
     * 
     * @type {number}
     * @memberof TransferCargoRequest
     */
    'units': number;
    /**
     * 
     * @type {string}
     * @memberof TransferCargoRequest
     */
    'shipSymbol': string;
}
/**
 * A waypoint is a location that ships can travel to such as a Planet, Moon or Space Station.
 * @export
 * @interface Waypoint
 */
export interface Waypoint {
    /**
     * 
     * @type {string}
     * @memberof Waypoint
     */
    'symbol': string;
    /**
     * 
     * @type {WaypointType}
     * @memberof Waypoint
     */
    'type': WaypointType;
    /**
     * 
     * @type {string}
     * @memberof Waypoint
     */
    'systemSymbol': string;
    /**
     * 
     * @type {number}
     * @memberof Waypoint
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof Waypoint
     */
    'y': number;
    /**
     * 
     * @type {Array<WaypointOrbital>}
     * @memberof Waypoint
     */
    'orbitals': Array<WaypointOrbital>;
    /**
     * 
     * @type {WaypointFaction}
     * @memberof Waypoint
     */
    'faction'?: WaypointFaction;
    /**
     * The traits of the waypoint.
     * @type {Array<WaypointTrait>}
     * @memberof Waypoint
     */
    'traits': Array<WaypointTrait>;
    /**
     * 
     * @type {Chart}
     * @memberof Waypoint
     */
    'chart'?: Chart;
}


/**
 * 
 * @export
 * @interface WaypointFaction
 */
export interface WaypointFaction {
    /**
     * 
     * @type {string}
     * @memberof WaypointFaction
     */
    'symbol': string;
}
/**
 * An orbital is another waypoint that orbits a parent waypoint.
 * @export
 * @interface WaypointOrbital
 */
export interface WaypointOrbital {
    /**
     * 
     * @type {string}
     * @memberof WaypointOrbital
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface WaypointTrait
 */
export interface WaypointTrait {
    /**
     * The unique identifier of the trait.
     * @type {string}
     * @memberof WaypointTrait
     */
    'symbol': WaypointTraitSymbolEnum;
    /**
     * The name of the trait.
     * @type {string}
     * @memberof WaypointTrait
     */
    'name': string;
    /**
     * A description of the trait.
     * @type {string}
     * @memberof WaypointTrait
     */
    'description': string;
}

export const WaypointTraitSymbolEnum = {
    Uncharted: 'UNCHARTED',
    Marketplace: 'MARKETPLACE',
    Shipyard: 'SHIPYARD',
    Outpost: 'OUTPOST',
    ScatteredSettlements: 'SCATTERED_SETTLEMENTS',
    SprawlingCities: 'SPRAWLING_CITIES',
    MegaStructures: 'MEGA_STRUCTURES',
    Overcrowded: 'OVERCROWDED',
    HighTech: 'HIGH_TECH',
    Corrupt: 'CORRUPT',
    Bureaucratic: 'BUREAUCRATIC',
    TradingHub: 'TRADING_HUB',
    Industrial: 'INDUSTRIAL',
    BlackMarket: 'BLACK_MARKET',
    ResearchFacility: 'RESEARCH_FACILITY',
    MilitaryBase: 'MILITARY_BASE',
    SurveillanceOutpost: 'SURVEILLANCE_OUTPOST',
    ExplorationOutpost: 'EXPLORATION_OUTPOST',
    MineralDeposits: 'MINERAL_DEPOSITS',
    CommonMetalDeposits: 'COMMON_METAL_DEPOSITS',
    PreciousMetalDeposits: 'PRECIOUS_METAL_DEPOSITS',
    RareMetalDeposits: 'RARE_METAL_DEPOSITS',
    MethanePools: 'METHANE_POOLS',
    IceCrystals: 'ICE_CRYSTALS',
    ExplosiveGases: 'EXPLOSIVE_GASES',
    StrongMagnetosphere: 'STRONG_MAGNETOSPHERE',
    VibrantAuroras: 'VIBRANT_AURORAS',
    SaltFlats: 'SALT_FLATS',
    Canyons: 'CANYONS',
    PerpetualDaylight: 'PERPETUAL_DAYLIGHT',
    PerpetualOvercast: 'PERPETUAL_OVERCAST',
    DrySeabeds: 'DRY_SEABEDS',
    MagmaSeas: 'MAGMA_SEAS',
    Supervolcanoes: 'SUPERVOLCANOES',
    AshClouds: 'ASH_CLOUDS',
    VastRuins: 'VAST_RUINS',
    MutatedFlora: 'MUTATED_FLORA',
    Terraformed: 'TERRAFORMED',
    ExtremeTemperatures: 'EXTREME_TEMPERATURES',
    ExtremePressure: 'EXTREME_PRESSURE',
    DiverseLife: 'DIVERSE_LIFE',
    ScarceLife: 'SCARCE_LIFE',
    Fossils: 'FOSSILS',
    WeakGravity: 'WEAK_GRAVITY',
    StrongGravity: 'STRONG_GRAVITY',
    CrushingGravity: 'CRUSHING_GRAVITY',
    ToxicAtmosphere: 'TOXIC_ATMOSPHERE',
    CorrosiveAtmosphere: 'CORROSIVE_ATMOSPHERE',
    BreathableAtmosphere: 'BREATHABLE_ATMOSPHERE',
    Jovian: 'JOVIAN',
    Rocky: 'ROCKY',
    Volcanic: 'VOLCANIC',
    Frozen: 'FROZEN',
    Swamp: 'SWAMP',
    Barren: 'BARREN',
    Temperate: 'TEMPERATE',
    Jungle: 'JUNGLE',
    Ocean: 'OCEAN',
    Stripped: 'STRIPPED'
} as const;

export type WaypointTraitSymbolEnum = typeof WaypointTraitSymbolEnum[keyof typeof WaypointTraitSymbolEnum];

/**
 * The type of waypoint.
 * @export
 * @enum {string}
 */

export const WaypointType = {
    Planet: 'PLANET',
    GasGiant: 'GAS_GIANT',
    Moon: 'MOON',
    OrbitalStation: 'ORBITAL_STATION',
    JumpGate: 'JUMP_GATE',
    AsteroidField: 'ASTEROID_FIELD',
    Nebula: 'NEBULA',
    DebrisField: 'DEBRIS_FIELD',
    GravityWell: 'GRAVITY_WELL'
} as const;

export type WaypointType = typeof WaypointType[keyof typeof WaypointType];



/**
 * AgentsApi - axios parameter creator
 * @export
 */
export const AgentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch your agent\'s details.
         * @summary My Agent Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyAgent: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/my/agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentsApi - functional programming interface
 * @export
 */
export const AgentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AgentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetch your agent\'s details.
         * @summary My Agent Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyAgent(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMyAgent200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyAgent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AgentsApi - factory interface
 * @export
 */
export const AgentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AgentsApiFp(configuration)
    return {
        /**
         * Fetch your agent\'s details.
         * @summary My Agent Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyAgent(options?: any): AxiosPromise<GetMyAgent200Response> {
            return localVarFp.getMyAgent(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AgentsApi - object-oriented interface
 * @export
 * @class AgentsApi
 * @extends {BaseAPI}
 */
export class AgentsApi extends BaseAPI {
    /**
     * Fetch your agent\'s details.
     * @summary My Agent Details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public getMyAgent(options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).getMyAgent(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContractsApi - axios parameter creator
 * @export
 */
export const ContractsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accept a contract.
         * @summary Accept Contract
         * @param {string} contractId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptContract: async (contractId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('acceptContract', 'contractId', contractId)
            const localVarPath = `/my/contracts/{contractId}/accept`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deliver cargo on a given contract.
         * @summary Deliver Contract
         * @param {string} contractId The ID of the contract
         * @param {DeliverContractRequest} [deliverContractRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliverContract: async (contractId: string, deliverContractRequest?: DeliverContractRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('deliverContract', 'contractId', contractId)
            const localVarPath = `/my/contracts/{contractId}/deliver`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deliverContractRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fulfill a contract
         * @summary Fulfill Contract
         * @param {string} contractId The ID of the contract
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fulfillContract: async (contractId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('fulfillContract', 'contractId', contractId)
            const localVarPath = `/my/contracts/{contractId}/fulfill`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the details of a contract by ID.
         * @summary Get Contract
         * @param {string} contractId The contract ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContract: async (contractId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('getContract', 'contractId', contractId)
            const localVarPath = `/my/contracts/{contractId}`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of your contracts.
         * @summary List Contracts
         * @param {number} [page] What entry offset to request
         * @param {number} [limit] How many entries to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContracts: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/my/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractsApi - functional programming interface
 * @export
 */
export const ContractsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractsApiAxiosParamCreator(configuration)
    return {
        /**
         * Accept a contract.
         * @summary Accept Contract
         * @param {string} contractId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptContract(contractId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AcceptContract200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptContract(contractId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deliver cargo on a given contract.
         * @summary Deliver Contract
         * @param {string} contractId The ID of the contract
         * @param {DeliverContractRequest} [deliverContractRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliverContract(contractId: string, deliverContractRequest?: DeliverContractRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeliverContract200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliverContract(contractId, deliverContractRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fulfill a contract
         * @summary Fulfill Contract
         * @param {string} contractId The ID of the contract
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fulfillContract(contractId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FulfillContract200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fulfillContract(contractId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the details of a contract by ID.
         * @summary Get Contract
         * @param {string} contractId The contract ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContract(contractId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContract200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContract(contractId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all of your contracts.
         * @summary List Contracts
         * @param {number} [page] What entry offset to request
         * @param {number} [limit] How many entries to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContracts(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContracts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContracts(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContractsApi - factory interface
 * @export
 */
export const ContractsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractsApiFp(configuration)
    return {
        /**
         * Accept a contract.
         * @summary Accept Contract
         * @param {string} contractId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptContract(contractId: string, options?: any): AxiosPromise<AcceptContract200Response> {
            return localVarFp.acceptContract(contractId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deliver cargo on a given contract.
         * @summary Deliver Contract
         * @param {string} contractId The ID of the contract
         * @param {DeliverContractRequest} [deliverContractRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliverContract(contractId: string, deliverContractRequest?: DeliverContractRequest, options?: any): AxiosPromise<DeliverContract200Response> {
            return localVarFp.deliverContract(contractId, deliverContractRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Fulfill a contract
         * @summary Fulfill Contract
         * @param {string} contractId The ID of the contract
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fulfillContract(contractId: string, options?: any): AxiosPromise<FulfillContract200Response> {
            return localVarFp.fulfillContract(contractId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the details of a contract by ID.
         * @summary Get Contract
         * @param {string} contractId The contract ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContract(contractId: string, options?: any): AxiosPromise<GetContract200Response> {
            return localVarFp.getContract(contractId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all of your contracts.
         * @summary List Contracts
         * @param {number} [page] What entry offset to request
         * @param {number} [limit] How many entries to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContracts(page?: number, limit?: number, options?: any): AxiosPromise<GetContracts200Response> {
            return localVarFp.getContracts(page, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContractsApi - object-oriented interface
 * @export
 * @class ContractsApi
 * @extends {BaseAPI}
 */
export class ContractsApi extends BaseAPI {
    /**
     * Accept a contract.
     * @summary Accept Contract
     * @param {string} contractId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public acceptContract(contractId: string, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).acceptContract(contractId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deliver cargo on a given contract.
     * @summary Deliver Contract
     * @param {string} contractId The ID of the contract
     * @param {DeliverContractRequest} [deliverContractRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public deliverContract(contractId: string, deliverContractRequest?: DeliverContractRequest, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).deliverContract(contractId, deliverContractRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fulfill a contract
     * @summary Fulfill Contract
     * @param {string} contractId The ID of the contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public fulfillContract(contractId: string, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).fulfillContract(contractId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the details of a contract by ID.
     * @summary Get Contract
     * @param {string} contractId The contract ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getContract(contractId: string, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).getContract(contractId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all of your contracts.
     * @summary List Contracts
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getContracts(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).getContracts(page, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return the status of the game server.
         * @summary Get Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new agent and ties it to a temporary Account.  The agent symbol is a 3-14 character string that will represent your agent. This symbol will prefix the symbol of every ship you own. Agent symbols will be cast to all uppercase characters.  A new agent will be granted an authorization token, a contract with their starting faction, a command ship with a jump drive, and one hundred thousand credits.  > #### Keep your token safe and secure > > Save your token during the alpha phase. There is no way to regenerate this token without starting a new agent. In the future you will be able to generate and manage your tokens from the SpaceTraders website.  You can accept your contract using the `/my/contracts/{contractId}/accept` endpoint. You will want to navigate your command ship to a nearby asteroid field and execute the `/my/ships/{shipSymbol}/extract` endpoint to mine various types of ores and minerals.  Return to the contract destination and execute the `/my/ships/{shipSymbol}/deliver` endpoint to deposit goods into the contract.  When your contract is fulfilled, you can call `/my/contracts/{contractId}/fulfill` to retrieve payment.
         * @summary Register New Agent
         * @param {RegisterRequest} [registerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerRequest?: RegisterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Return the status of the game server.
         * @summary Get Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new agent and ties it to a temporary Account.  The agent symbol is a 3-14 character string that will represent your agent. This symbol will prefix the symbol of every ship you own. Agent symbols will be cast to all uppercase characters.  A new agent will be granted an authorization token, a contract with their starting faction, a command ship with a jump drive, and one hundred thousand credits.  > #### Keep your token safe and secure > > Save your token during the alpha phase. There is no way to regenerate this token without starting a new agent. In the future you will be able to generate and manage your tokens from the SpaceTraders website.  You can accept your contract using the `/my/contracts/{contractId}/accept` endpoint. You will want to navigate your command ship to a nearby asteroid field and execute the `/my/ships/{shipSymbol}/extract` endpoint to mine various types of ores and minerals.  Return to the contract destination and execute the `/my/ships/{shipSymbol}/deliver` endpoint to deposit goods into the contract.  When your contract is fulfilled, you can call `/my/contracts/{contractId}/fulfill` to retrieve payment.
         * @summary Register New Agent
         * @param {RegisterRequest} [registerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerRequest?: RegisterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Register201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Return the status of the game server.
         * @summary Get Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any): AxiosPromise<GetStatus200Response> {
            return localVarFp.getStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new agent and ties it to a temporary Account.  The agent symbol is a 3-14 character string that will represent your agent. This symbol will prefix the symbol of every ship you own. Agent symbols will be cast to all uppercase characters.  A new agent will be granted an authorization token, a contract with their starting faction, a command ship with a jump drive, and one hundred thousand credits.  > #### Keep your token safe and secure > > Save your token during the alpha phase. There is no way to regenerate this token without starting a new agent. In the future you will be able to generate and manage your tokens from the SpaceTraders website.  You can accept your contract using the `/my/contracts/{contractId}/accept` endpoint. You will want to navigate your command ship to a nearby asteroid field and execute the `/my/ships/{shipSymbol}/extract` endpoint to mine various types of ores and minerals.  Return to the contract destination and execute the `/my/ships/{shipSymbol}/deliver` endpoint to deposit goods into the contract.  When your contract is fulfilled, you can call `/my/contracts/{contractId}/fulfill` to retrieve payment.
         * @summary Register New Agent
         * @param {RegisterRequest} [registerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerRequest?: RegisterRequest, options?: any): AxiosPromise<Register201Response> {
            return localVarFp.register(registerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Return the status of the game server.
     * @summary Get Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStatus(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new agent and ties it to a temporary Account.  The agent symbol is a 3-14 character string that will represent your agent. This symbol will prefix the symbol of every ship you own. Agent symbols will be cast to all uppercase characters.  A new agent will be granted an authorization token, a contract with their starting faction, a command ship with a jump drive, and one hundred thousand credits.  > #### Keep your token safe and secure > > Save your token during the alpha phase. There is no way to regenerate this token without starting a new agent. In the future you will be able to generate and manage your tokens from the SpaceTraders website.  You can accept your contract using the `/my/contracts/{contractId}/accept` endpoint. You will want to navigate your command ship to a nearby asteroid field and execute the `/my/ships/{shipSymbol}/extract` endpoint to mine various types of ores and minerals.  Return to the contract destination and execute the `/my/ships/{shipSymbol}/deliver` endpoint to deposit goods into the contract.  When your contract is fulfilled, you can call `/my/contracts/{contractId}/fulfill` to retrieve payment.
     * @summary Register New Agent
     * @param {RegisterRequest} [registerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public register(registerRequest?: RegisterRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).register(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FactionsApi - axios parameter creator
 * @export
 */
export const FactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * View the details of a faction.
         * @summary Get Faction
         * @param {string} factionSymbol The faction symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaction: async (factionSymbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'factionSymbol' is not null or undefined
            assertParamExists('getFaction', 'factionSymbol', factionSymbol)
            const localVarPath = `/factions/{factionSymbol}`
                .replace(`{${"factionSymbol"}}`, encodeURIComponent(String(factionSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all discovered factions in the game.
         * @summary List Factions
         * @param {number} [page] What entry offset to request
         * @param {number} [limit] How many entries to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFactions: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/factions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FactionsApi - functional programming interface
 * @export
 */
export const FactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * View the details of a faction.
         * @summary Get Faction
         * @param {string} factionSymbol The faction symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFaction(factionSymbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFaction200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFaction(factionSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all discovered factions in the game.
         * @summary List Factions
         * @param {number} [page] What entry offset to request
         * @param {number} [limit] How many entries to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFactions(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFactions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFactions(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FactionsApi - factory interface
 * @export
 */
export const FactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FactionsApiFp(configuration)
    return {
        /**
         * View the details of a faction.
         * @summary Get Faction
         * @param {string} factionSymbol The faction symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaction(factionSymbol: string, options?: any): AxiosPromise<GetFaction200Response> {
            return localVarFp.getFaction(factionSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * List all discovered factions in the game.
         * @summary List Factions
         * @param {number} [page] What entry offset to request
         * @param {number} [limit] How many entries to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFactions(page?: number, limit?: number, options?: any): AxiosPromise<GetFactions200Response> {
            return localVarFp.getFactions(page, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FactionsApi - object-oriented interface
 * @export
 * @class FactionsApi
 * @extends {BaseAPI}
 */
export class FactionsApi extends BaseAPI {
    /**
     * View the details of a faction.
     * @summary Get Faction
     * @param {string} factionSymbol The faction symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionsApi
     */
    public getFaction(factionSymbol: string, options?: AxiosRequestConfig) {
        return FactionsApiFp(this.configuration).getFaction(factionSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all discovered factions in the game.
     * @summary List Factions
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionsApi
     */
    public getFactions(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return FactionsApiFp(this.configuration).getFactions(page, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FleetApi - axios parameter creator
 * @export
 */
export const FleetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Command a ship to chart the current waypoint.  Waypoints in the universe are uncharted by default. These locations will not show up in the API until they have been charted by a ship.  Charting a location will record your agent as the one who created the chart.
         * @summary Create Chart
         * @param {string} shipSymbol The symbol of the ship
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChart: async (shipSymbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('createChart', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/chart`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activate your ship\'s sensor arrays to scan for ship information.
         * @summary Scan Ships
         * @param {string} shipSymbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipShipScan: async (shipSymbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('createShipShipScan', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/scan/ships`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activate your ship\'s sensor arrays to scan for system information.
         * @summary Scan Systems
         * @param {string} shipSymbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipSystemScan: async (shipSymbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('createShipSystemScan', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/scan/systems`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activate your ship\'s sensor arrays to scan for waypoint information.
         * @summary Scan Waypoints
         * @param {string} shipSymbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipWaypointScan: async (shipSymbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('createShipWaypointScan', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/scan/waypoints`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you want to target specific yields for an extraction, you can survey a waypoint, such as an asteroid field, and send the survey in the body of the extract request. Each survey may have multiple deposits, and if a symbol shows up more than once, that indicates a higher chance of extracting that resource.  Your ship will enter a cooldown between consecutive survey requests. Surveys will eventually expire after a period of time. Multiple ships can use the same survey for extraction.
         * @summary Create Survey
         * @param {string} shipSymbol The symbol of the ship
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSurvey: async (shipSymbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('createSurvey', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/survey`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attempt to dock your ship at it\'s current location. Docking will only succeed if the waypoint is a dockable location, and your ship is capable of docking at the time of the request.  The endpoint is idempotent - successive calls will succeed even if the ship is already docked.
         * @summary Dock Ship
         * @param {string} shipSymbol The symbol of the ship
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dockShip: async (shipSymbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('dockShip', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/dock`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Extract resources from the waypoint into your ship. Send an optional survey as the payload to target specific yields.
         * @summary Extract Resources
         * @param {string} shipSymbol The ship symbol
         * @param {ExtractResourcesRequest} [extractResourcesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extractResources: async (shipSymbol: string, extractResourcesRequest?: ExtractResourcesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('extractResources', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/extract`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(extractResourcesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the mounts on a ship.
         * @summary Get Mounts
         * @param {string} shipSymbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMounts: async (shipSymbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('getMounts', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/mounts`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of your ship.
         * @summary Get Ship
         * @param {string} shipSymbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyShip: async (shipSymbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('getMyShip', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the cargo of your ship.
         * @summary Get Ship Cargo
         * @param {string} shipSymbol The symbol of the ship
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyShipCargo: async (shipSymbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('getMyShipCargo', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/cargo`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all of your ships.
         * @summary List Ships
         * @param {number} [page] What entry offset to request
         * @param {number} [limit] How many entries to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyShips: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/my/ships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of your ship\'s reactor cooldown. Some actions such as activating your jump drive, scanning, or extracting resources taxes your reactor and results in a cooldown.  Your ship cannot perform additional actions until your cooldown has expired. The duration of your cooldown is relative to the power consumption of the related modules or mounts for the action taken.  Response returns a 204 status code (no-content) when the ship has no cooldown.
         * @summary Get Ship Cooldown
         * @param {string} shipSymbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShipCooldown: async (shipSymbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('getShipCooldown', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/cooldown`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current nav status of a ship.
         * @summary Get Ship Nav
         * @param {string} shipSymbol The ship symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShipNav: async (shipSymbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('getShipNav', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/nav`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Install a mount on a ship.
         * @summary Install Mount
         * @param {string} shipSymbol 
         * @param {InstallMountRequest} [installMountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installMount: async (shipSymbol: string, installMountRequest?: InstallMountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('installMount', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/mounts/install`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(installMountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Jettison cargo from your ship\'s cargo hold.
         * @summary Jettison Cargo
         * @param {string} shipSymbol 
         * @param {JettisonRequest} [jettisonRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jettison: async (shipSymbol: string, jettisonRequest?: JettisonRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('jettison', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/jettison`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jettisonRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Jump your ship instantly to a target system. When used while in orbit or docked to a jump gate waypoint, any ship can use this command. When used elsewhere, jumping requires a jump drive unit and consumes a unit of antimatter (which needs to be in your cargo).
         * @summary Jump Ship
         * @param {string} shipSymbol 
         * @param {JumpShipRequest} [jumpShipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jumpShip: async (shipSymbol: string, jumpShipRequest?: JumpShipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('jumpShip', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/jump`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jumpShipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Navigate to a target destination. The destination must be located within the same system as the ship. Navigating will consume the necessary fuel and supplies from the ship\'s manifest, and will pay out crew wages from the agent\'s account.  The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at it\'s destination.  To travel between systems, see the ship\'s warp or jump actions.
         * @summary Navigate Ship
         * @param {string} shipSymbol The ship symbol
         * @param {NavigateShipRequest} [navigateShipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        navigateShip: async (shipSymbol: string, navigateShipRequest?: NavigateShipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('navigateShip', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/navigate`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(navigateShipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Negotiate Contract
         * @param {string} shipSymbol 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiateContract: async (shipSymbol: string, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('negotiateContract', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/negotiate/contract`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attempt to move your ship into orbit at it\'s current location. The request will only succeed if your ship is capable of moving into orbit at the time of the request.  The endpoint is idempotent - successive calls will succeed even if the ship is already in orbit.
         * @summary Orbit Ship
         * @param {string} shipSymbol The symbol of the ship
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orbitShip: async (shipSymbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('orbitShip', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/orbit`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the nav data of a ship, such as the flight mode.
         * @summary Patch Ship Nav
         * @param {string} shipSymbol The ship symbol
         * @param {PatchShipNavRequest} [patchShipNavRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchShipNav: async (shipSymbol: string, patchShipNavRequest?: PatchShipNavRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('patchShipNav', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/nav`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchShipNavRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Purchase cargo.
         * @summary Purchase Cargo
         * @param {string} shipSymbol 
         * @param {PurchaseCargoRequest} [purchaseCargoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseCargo: async (shipSymbol: string, purchaseCargoRequest?: PurchaseCargoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('purchaseCargo', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/purchase`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(purchaseCargoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Purchase a ship
         * @summary Purchase Ship
         * @param {PurchaseShipRequest} [purchaseShipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseShip: async (purchaseShipRequest?: PurchaseShipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/my/ships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(purchaseShipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refuel your ship from the local market.
         * @summary Refuel Ship
         * @param {string} shipSymbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refuelShip: async (shipSymbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('refuelShip', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/refuel`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a mount from a ship.
         * @summary Remove Mount
         * @param {string} shipSymbol 
         * @param {RemoveMountRequest} [removeMountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMount: async (shipSymbol: string, removeMountRequest?: RemoveMountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('removeMount', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/mounts/remove`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeMountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sell cargo.
         * @summary Sell Cargo
         * @param {string} shipSymbol 
         * @param {SellCargoRequest} [sellCargoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellCargo: async (shipSymbol: string, sellCargoRequest?: SellCargoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('sellCargo', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/sell`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sellCargoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attempt to refine the raw materials on your ship. The request will only succeed if your ship is capable of refining at the time of the request.
         * @summary Ship Refine
         * @param {string} shipSymbol The symbol of the ship
         * @param {ShipRefineRequest} [shipRefineRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipRefine: async (shipSymbol: string, shipRefineRequest?: ShipRefineRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('shipRefine', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/refine`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shipRefineRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transfer cargo between ships.
         * @summary Transfer Cargo
         * @param {string} shipSymbol 
         * @param {TransferCargoRequest} [transferCargoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferCargo: async (shipSymbol: string, transferCargoRequest?: TransferCargoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('transferCargo', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/transfer`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transferCargoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Warp your ship to a target destination in another system. Warping will consume the necessary fuel and supplies from the ship\'s manifest, and will pay out crew wages from the agent\'s account.  The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at it\'s destination.
         * @summary Warp Ship
         * @param {string} shipSymbol 
         * @param {NavigateShipRequest} [navigateShipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        warpShip: async (shipSymbol: string, navigateShipRequest?: NavigateShipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipSymbol' is not null or undefined
            assertParamExists('warpShip', 'shipSymbol', shipSymbol)
            const localVarPath = `/my/ships/{shipSymbol}/warp`
                .replace(`{${"shipSymbol"}}`, encodeURIComponent(String(shipSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(navigateShipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FleetApi - functional programming interface
 * @export
 */
export const FleetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FleetApiAxiosParamCreator(configuration)
    return {
        /**
         * Command a ship to chart the current waypoint.  Waypoints in the universe are uncharted by default. These locations will not show up in the API until they have been charted by a ship.  Charting a location will record your agent as the one who created the chart.
         * @summary Create Chart
         * @param {string} shipSymbol The symbol of the ship
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChart(shipSymbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateChart201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChart(shipSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Activate your ship\'s sensor arrays to scan for ship information.
         * @summary Scan Ships
         * @param {string} shipSymbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShipShipScan(shipSymbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateShipShipScan201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShipShipScan(shipSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Activate your ship\'s sensor arrays to scan for system information.
         * @summary Scan Systems
         * @param {string} shipSymbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShipSystemScan(shipSymbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateShipSystemScan201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShipSystemScan(shipSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Activate your ship\'s sensor arrays to scan for waypoint information.
         * @summary Scan Waypoints
         * @param {string} shipSymbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShipWaypointScan(shipSymbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateShipWaypointScan201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShipWaypointScan(shipSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If you want to target specific yields for an extraction, you can survey a waypoint, such as an asteroid field, and send the survey in the body of the extract request. Each survey may have multiple deposits, and if a symbol shows up more than once, that indicates a higher chance of extracting that resource.  Your ship will enter a cooldown between consecutive survey requests. Surveys will eventually expire after a period of time. Multiple ships can use the same survey for extraction.
         * @summary Create Survey
         * @param {string} shipSymbol The symbol of the ship
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSurvey(shipSymbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSurvey201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSurvey(shipSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Attempt to dock your ship at it\'s current location. Docking will only succeed if the waypoint is a dockable location, and your ship is capable of docking at the time of the request.  The endpoint is idempotent - successive calls will succeed even if the ship is already docked.
         * @summary Dock Ship
         * @param {string} shipSymbol The symbol of the ship
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dockShip(shipSymbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DockShip200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dockShip(shipSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Extract resources from the waypoint into your ship. Send an optional survey as the payload to target specific yields.
         * @summary Extract Resources
         * @param {string} shipSymbol The ship symbol
         * @param {ExtractResourcesRequest} [extractResourcesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extractResources(shipSymbol: string, extractResourcesRequest?: ExtractResourcesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtractResources201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extractResources(shipSymbol, extractResourcesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the mounts on a ship.
         * @summary Get Mounts
         * @param {string} shipSymbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMounts(shipSymbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMounts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMounts(shipSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the details of your ship.
         * @summary Get Ship
         * @param {string} shipSymbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyShip(shipSymbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMyShip200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyShip(shipSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the cargo of your ship.
         * @summary Get Ship Cargo
         * @param {string} shipSymbol The symbol of the ship
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyShipCargo(shipSymbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMyShipCargo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyShipCargo(shipSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all of your ships.
         * @summary List Ships
         * @param {number} [page] What entry offset to request
         * @param {number} [limit] How many entries to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyShips(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMyShips200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyShips(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the details of your ship\'s reactor cooldown. Some actions such as activating your jump drive, scanning, or extracting resources taxes your reactor and results in a cooldown.  Your ship cannot perform additional actions until your cooldown has expired. The duration of your cooldown is relative to the power consumption of the related modules or mounts for the action taken.  Response returns a 204 status code (no-content) when the ship has no cooldown.
         * @summary Get Ship Cooldown
         * @param {string} shipSymbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShipCooldown(shipSymbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetShipCooldown200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShipCooldown(shipSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the current nav status of a ship.
         * @summary Get Ship Nav
         * @param {string} shipSymbol The ship symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShipNav(shipSymbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetShipNav200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShipNav(shipSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Install a mount on a ship.
         * @summary Install Mount
         * @param {string} shipSymbol 
         * @param {InstallMountRequest} [installMountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async installMount(shipSymbol: string, installMountRequest?: InstallMountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstallMount201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.installMount(shipSymbol, installMountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Jettison cargo from your ship\'s cargo hold.
         * @summary Jettison Cargo
         * @param {string} shipSymbol 
         * @param {JettisonRequest} [jettisonRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jettison(shipSymbol: string, jettisonRequest?: JettisonRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Jettison200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jettison(shipSymbol, jettisonRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Jump your ship instantly to a target system. When used while in orbit or docked to a jump gate waypoint, any ship can use this command. When used elsewhere, jumping requires a jump drive unit and consumes a unit of antimatter (which needs to be in your cargo).
         * @summary Jump Ship
         * @param {string} shipSymbol 
         * @param {JumpShipRequest} [jumpShipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jumpShip(shipSymbol: string, jumpShipRequest?: JumpShipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JumpShip200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jumpShip(shipSymbol, jumpShipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Navigate to a target destination. The destination must be located within the same system as the ship. Navigating will consume the necessary fuel and supplies from the ship\'s manifest, and will pay out crew wages from the agent\'s account.  The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at it\'s destination.  To travel between systems, see the ship\'s warp or jump actions.
         * @summary Navigate Ship
         * @param {string} shipSymbol The ship symbol
         * @param {NavigateShipRequest} [navigateShipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async navigateShip(shipSymbol: string, navigateShipRequest?: NavigateShipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NavigateShip200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.navigateShip(shipSymbol, navigateShipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Negotiate Contract
         * @param {string} shipSymbol 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async negotiateContract(shipSymbol: string, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NegotiateContract200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.negotiateContract(shipSymbol, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Attempt to move your ship into orbit at it\'s current location. The request will only succeed if your ship is capable of moving into orbit at the time of the request.  The endpoint is idempotent - successive calls will succeed even if the ship is already in orbit.
         * @summary Orbit Ship
         * @param {string} shipSymbol The symbol of the ship
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orbitShip(shipSymbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrbitShip200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orbitShip(shipSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the nav data of a ship, such as the flight mode.
         * @summary Patch Ship Nav
         * @param {string} shipSymbol The ship symbol
         * @param {PatchShipNavRequest} [patchShipNavRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchShipNav(shipSymbol: string, patchShipNavRequest?: PatchShipNavRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetShipNav200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchShipNav(shipSymbol, patchShipNavRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Purchase cargo.
         * @summary Purchase Cargo
         * @param {string} shipSymbol 
         * @param {PurchaseCargoRequest} [purchaseCargoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseCargo(shipSymbol: string, purchaseCargoRequest?: PurchaseCargoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PurchaseCargo201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseCargo(shipSymbol, purchaseCargoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Purchase a ship
         * @summary Purchase Ship
         * @param {PurchaseShipRequest} [purchaseShipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseShip(purchaseShipRequest?: PurchaseShipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PurchaseShip201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseShip(purchaseShipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refuel your ship from the local market.
         * @summary Refuel Ship
         * @param {string} shipSymbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refuelShip(shipSymbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefuelShip200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refuelShip(shipSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a mount from a ship.
         * @summary Remove Mount
         * @param {string} shipSymbol 
         * @param {RemoveMountRequest} [removeMountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeMount(shipSymbol: string, removeMountRequest?: RemoveMountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoveMount201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeMount(shipSymbol, removeMountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sell cargo.
         * @summary Sell Cargo
         * @param {string} shipSymbol 
         * @param {SellCargoRequest} [sellCargoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sellCargo(shipSymbol: string, sellCargoRequest?: SellCargoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SellCargo201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sellCargo(shipSymbol, sellCargoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Attempt to refine the raw materials on your ship. The request will only succeed if your ship is capable of refining at the time of the request.
         * @summary Ship Refine
         * @param {string} shipSymbol The symbol of the ship
         * @param {ShipRefineRequest} [shipRefineRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shipRefine(shipSymbol: string, shipRefineRequest?: ShipRefineRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShipRefine200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shipRefine(shipSymbol, shipRefineRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Transfer cargo between ships.
         * @summary Transfer Cargo
         * @param {string} shipSymbol 
         * @param {TransferCargoRequest} [transferCargoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transferCargo(shipSymbol: string, transferCargoRequest?: TransferCargoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferCargo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transferCargo(shipSymbol, transferCargoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Warp your ship to a target destination in another system. Warping will consume the necessary fuel and supplies from the ship\'s manifest, and will pay out crew wages from the agent\'s account.  The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at it\'s destination.
         * @summary Warp Ship
         * @param {string} shipSymbol 
         * @param {NavigateShipRequest} [navigateShipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async warpShip(shipSymbol: string, navigateShipRequest?: NavigateShipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NavigateShip200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.warpShip(shipSymbol, navigateShipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FleetApi - factory interface
 * @export
 */
export const FleetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FleetApiFp(configuration)
    return {
        /**
         * Command a ship to chart the current waypoint.  Waypoints in the universe are uncharted by default. These locations will not show up in the API until they have been charted by a ship.  Charting a location will record your agent as the one who created the chart.
         * @summary Create Chart
         * @param {string} shipSymbol The symbol of the ship
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChart(shipSymbol: string, options?: any): AxiosPromise<CreateChart201Response> {
            return localVarFp.createChart(shipSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Activate your ship\'s sensor arrays to scan for ship information.
         * @summary Scan Ships
         * @param {string} shipSymbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipShipScan(shipSymbol: string, options?: any): AxiosPromise<CreateShipShipScan201Response> {
            return localVarFp.createShipShipScan(shipSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Activate your ship\'s sensor arrays to scan for system information.
         * @summary Scan Systems
         * @param {string} shipSymbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipSystemScan(shipSymbol: string, options?: any): AxiosPromise<CreateShipSystemScan201Response> {
            return localVarFp.createShipSystemScan(shipSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Activate your ship\'s sensor arrays to scan for waypoint information.
         * @summary Scan Waypoints
         * @param {string} shipSymbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipWaypointScan(shipSymbol: string, options?: any): AxiosPromise<CreateShipWaypointScan201Response> {
            return localVarFp.createShipWaypointScan(shipSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * If you want to target specific yields for an extraction, you can survey a waypoint, such as an asteroid field, and send the survey in the body of the extract request. Each survey may have multiple deposits, and if a symbol shows up more than once, that indicates a higher chance of extracting that resource.  Your ship will enter a cooldown between consecutive survey requests. Surveys will eventually expire after a period of time. Multiple ships can use the same survey for extraction.
         * @summary Create Survey
         * @param {string} shipSymbol The symbol of the ship
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSurvey(shipSymbol: string, options?: any): AxiosPromise<CreateSurvey201Response> {
            return localVarFp.createSurvey(shipSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Attempt to dock your ship at it\'s current location. Docking will only succeed if the waypoint is a dockable location, and your ship is capable of docking at the time of the request.  The endpoint is idempotent - successive calls will succeed even if the ship is already docked.
         * @summary Dock Ship
         * @param {string} shipSymbol The symbol of the ship
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dockShip(shipSymbol: string, options?: any): AxiosPromise<DockShip200Response> {
            return localVarFp.dockShip(shipSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Extract resources from the waypoint into your ship. Send an optional survey as the payload to target specific yields.
         * @summary Extract Resources
         * @param {string} shipSymbol The ship symbol
         * @param {ExtractResourcesRequest} [extractResourcesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extractResources(shipSymbol: string, extractResourcesRequest?: ExtractResourcesRequest, options?: any): AxiosPromise<ExtractResources201Response> {
            return localVarFp.extractResources(shipSymbol, extractResourcesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the mounts on a ship.
         * @summary Get Mounts
         * @param {string} shipSymbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMounts(shipSymbol: string, options?: any): AxiosPromise<GetMounts200Response> {
            return localVarFp.getMounts(shipSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of your ship.
         * @summary Get Ship
         * @param {string} shipSymbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyShip(shipSymbol: string, options?: any): AxiosPromise<GetMyShip200Response> {
            return localVarFp.getMyShip(shipSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the cargo of your ship.
         * @summary Get Ship Cargo
         * @param {string} shipSymbol The symbol of the ship
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyShipCargo(shipSymbol: string, options?: any): AxiosPromise<GetMyShipCargo200Response> {
            return localVarFp.getMyShipCargo(shipSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all of your ships.
         * @summary List Ships
         * @param {number} [page] What entry offset to request
         * @param {number} [limit] How many entries to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyShips(page?: number, limit?: number, options?: any): AxiosPromise<GetMyShips200Response> {
            return localVarFp.getMyShips(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of your ship\'s reactor cooldown. Some actions such as activating your jump drive, scanning, or extracting resources taxes your reactor and results in a cooldown.  Your ship cannot perform additional actions until your cooldown has expired. The duration of your cooldown is relative to the power consumption of the related modules or mounts for the action taken.  Response returns a 204 status code (no-content) when the ship has no cooldown.
         * @summary Get Ship Cooldown
         * @param {string} shipSymbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShipCooldown(shipSymbol: string, options?: any): AxiosPromise<GetShipCooldown200Response> {
            return localVarFp.getShipCooldown(shipSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current nav status of a ship.
         * @summary Get Ship Nav
         * @param {string} shipSymbol The ship symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShipNav(shipSymbol: string, options?: any): AxiosPromise<GetShipNav200Response> {
            return localVarFp.getShipNav(shipSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Install a mount on a ship.
         * @summary Install Mount
         * @param {string} shipSymbol 
         * @param {InstallMountRequest} [installMountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installMount(shipSymbol: string, installMountRequest?: InstallMountRequest, options?: any): AxiosPromise<InstallMount201Response> {
            return localVarFp.installMount(shipSymbol, installMountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Jettison cargo from your ship\'s cargo hold.
         * @summary Jettison Cargo
         * @param {string} shipSymbol 
         * @param {JettisonRequest} [jettisonRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jettison(shipSymbol: string, jettisonRequest?: JettisonRequest, options?: any): AxiosPromise<Jettison200Response> {
            return localVarFp.jettison(shipSymbol, jettisonRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Jump your ship instantly to a target system. When used while in orbit or docked to a jump gate waypoint, any ship can use this command. When used elsewhere, jumping requires a jump drive unit and consumes a unit of antimatter (which needs to be in your cargo).
         * @summary Jump Ship
         * @param {string} shipSymbol 
         * @param {JumpShipRequest} [jumpShipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jumpShip(shipSymbol: string, jumpShipRequest?: JumpShipRequest, options?: any): AxiosPromise<JumpShip200Response> {
            return localVarFp.jumpShip(shipSymbol, jumpShipRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Navigate to a target destination. The destination must be located within the same system as the ship. Navigating will consume the necessary fuel and supplies from the ship\'s manifest, and will pay out crew wages from the agent\'s account.  The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at it\'s destination.  To travel between systems, see the ship\'s warp or jump actions.
         * @summary Navigate Ship
         * @param {string} shipSymbol The ship symbol
         * @param {NavigateShipRequest} [navigateShipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        navigateShip(shipSymbol: string, navigateShipRequest?: NavigateShipRequest, options?: any): AxiosPromise<NavigateShip200Response> {
            return localVarFp.navigateShip(shipSymbol, navigateShipRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Negotiate Contract
         * @param {string} shipSymbol 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiateContract(shipSymbol: string, body?: any, options?: any): AxiosPromise<NegotiateContract200Response> {
            return localVarFp.negotiateContract(shipSymbol, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Attempt to move your ship into orbit at it\'s current location. The request will only succeed if your ship is capable of moving into orbit at the time of the request.  The endpoint is idempotent - successive calls will succeed even if the ship is already in orbit.
         * @summary Orbit Ship
         * @param {string} shipSymbol The symbol of the ship
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orbitShip(shipSymbol: string, options?: any): AxiosPromise<OrbitShip200Response> {
            return localVarFp.orbitShip(shipSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the nav data of a ship, such as the flight mode.
         * @summary Patch Ship Nav
         * @param {string} shipSymbol The ship symbol
         * @param {PatchShipNavRequest} [patchShipNavRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchShipNav(shipSymbol: string, patchShipNavRequest?: PatchShipNavRequest, options?: any): AxiosPromise<GetShipNav200Response> {
            return localVarFp.patchShipNav(shipSymbol, patchShipNavRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Purchase cargo.
         * @summary Purchase Cargo
         * @param {string} shipSymbol 
         * @param {PurchaseCargoRequest} [purchaseCargoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseCargo(shipSymbol: string, purchaseCargoRequest?: PurchaseCargoRequest, options?: any): AxiosPromise<PurchaseCargo201Response> {
            return localVarFp.purchaseCargo(shipSymbol, purchaseCargoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Purchase a ship
         * @summary Purchase Ship
         * @param {PurchaseShipRequest} [purchaseShipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseShip(purchaseShipRequest?: PurchaseShipRequest, options?: any): AxiosPromise<PurchaseShip201Response> {
            return localVarFp.purchaseShip(purchaseShipRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Refuel your ship from the local market.
         * @summary Refuel Ship
         * @param {string} shipSymbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refuelShip(shipSymbol: string, options?: any): AxiosPromise<RefuelShip200Response> {
            return localVarFp.refuelShip(shipSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a mount from a ship.
         * @summary Remove Mount
         * @param {string} shipSymbol 
         * @param {RemoveMountRequest} [removeMountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMount(shipSymbol: string, removeMountRequest?: RemoveMountRequest, options?: any): AxiosPromise<RemoveMount201Response> {
            return localVarFp.removeMount(shipSymbol, removeMountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Sell cargo.
         * @summary Sell Cargo
         * @param {string} shipSymbol 
         * @param {SellCargoRequest} [sellCargoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellCargo(shipSymbol: string, sellCargoRequest?: SellCargoRequest, options?: any): AxiosPromise<SellCargo201Response> {
            return localVarFp.sellCargo(shipSymbol, sellCargoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Attempt to refine the raw materials on your ship. The request will only succeed if your ship is capable of refining at the time of the request.
         * @summary Ship Refine
         * @param {string} shipSymbol The symbol of the ship
         * @param {ShipRefineRequest} [shipRefineRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipRefine(shipSymbol: string, shipRefineRequest?: ShipRefineRequest, options?: any): AxiosPromise<ShipRefine200Response> {
            return localVarFp.shipRefine(shipSymbol, shipRefineRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Transfer cargo between ships.
         * @summary Transfer Cargo
         * @param {string} shipSymbol 
         * @param {TransferCargoRequest} [transferCargoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferCargo(shipSymbol: string, transferCargoRequest?: TransferCargoRequest, options?: any): AxiosPromise<TransferCargo200Response> {
            return localVarFp.transferCargo(shipSymbol, transferCargoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Warp your ship to a target destination in another system. Warping will consume the necessary fuel and supplies from the ship\'s manifest, and will pay out crew wages from the agent\'s account.  The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at it\'s destination.
         * @summary Warp Ship
         * @param {string} shipSymbol 
         * @param {NavigateShipRequest} [navigateShipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        warpShip(shipSymbol: string, navigateShipRequest?: NavigateShipRequest, options?: any): AxiosPromise<NavigateShip200Response> {
            return localVarFp.warpShip(shipSymbol, navigateShipRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FleetApi - object-oriented interface
 * @export
 * @class FleetApi
 * @extends {BaseAPI}
 */
export class FleetApi extends BaseAPI {
    /**
     * Command a ship to chart the current waypoint.  Waypoints in the universe are uncharted by default. These locations will not show up in the API until they have been charted by a ship.  Charting a location will record your agent as the one who created the chart.
     * @summary Create Chart
     * @param {string} shipSymbol The symbol of the ship
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public createChart(shipSymbol: string, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).createChart(shipSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activate your ship\'s sensor arrays to scan for ship information.
     * @summary Scan Ships
     * @param {string} shipSymbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public createShipShipScan(shipSymbol: string, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).createShipShipScan(shipSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activate your ship\'s sensor arrays to scan for system information.
     * @summary Scan Systems
     * @param {string} shipSymbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public createShipSystemScan(shipSymbol: string, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).createShipSystemScan(shipSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activate your ship\'s sensor arrays to scan for waypoint information.
     * @summary Scan Waypoints
     * @param {string} shipSymbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public createShipWaypointScan(shipSymbol: string, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).createShipWaypointScan(shipSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you want to target specific yields for an extraction, you can survey a waypoint, such as an asteroid field, and send the survey in the body of the extract request. Each survey may have multiple deposits, and if a symbol shows up more than once, that indicates a higher chance of extracting that resource.  Your ship will enter a cooldown between consecutive survey requests. Surveys will eventually expire after a period of time. Multiple ships can use the same survey for extraction.
     * @summary Create Survey
     * @param {string} shipSymbol The symbol of the ship
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public createSurvey(shipSymbol: string, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).createSurvey(shipSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attempt to dock your ship at it\'s current location. Docking will only succeed if the waypoint is a dockable location, and your ship is capable of docking at the time of the request.  The endpoint is idempotent - successive calls will succeed even if the ship is already docked.
     * @summary Dock Ship
     * @param {string} shipSymbol The symbol of the ship
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public dockShip(shipSymbol: string, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).dockShip(shipSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Extract resources from the waypoint into your ship. Send an optional survey as the payload to target specific yields.
     * @summary Extract Resources
     * @param {string} shipSymbol The ship symbol
     * @param {ExtractResourcesRequest} [extractResourcesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public extractResources(shipSymbol: string, extractResourcesRequest?: ExtractResourcesRequest, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).extractResources(shipSymbol, extractResourcesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the mounts on a ship.
     * @summary Get Mounts
     * @param {string} shipSymbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public getMounts(shipSymbol: string, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).getMounts(shipSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of your ship.
     * @summary Get Ship
     * @param {string} shipSymbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public getMyShip(shipSymbol: string, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).getMyShip(shipSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the cargo of your ship.
     * @summary Get Ship Cargo
     * @param {string} shipSymbol The symbol of the ship
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public getMyShipCargo(shipSymbol: string, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).getMyShipCargo(shipSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all of your ships.
     * @summary List Ships
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public getMyShips(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).getMyShips(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of your ship\'s reactor cooldown. Some actions such as activating your jump drive, scanning, or extracting resources taxes your reactor and results in a cooldown.  Your ship cannot perform additional actions until your cooldown has expired. The duration of your cooldown is relative to the power consumption of the related modules or mounts for the action taken.  Response returns a 204 status code (no-content) when the ship has no cooldown.
     * @summary Get Ship Cooldown
     * @param {string} shipSymbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public getShipCooldown(shipSymbol: string, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).getShipCooldown(shipSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current nav status of a ship.
     * @summary Get Ship Nav
     * @param {string} shipSymbol The ship symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public getShipNav(shipSymbol: string, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).getShipNav(shipSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Install a mount on a ship.
     * @summary Install Mount
     * @param {string} shipSymbol 
     * @param {InstallMountRequest} [installMountRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public installMount(shipSymbol: string, installMountRequest?: InstallMountRequest, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).installMount(shipSymbol, installMountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Jettison cargo from your ship\'s cargo hold.
     * @summary Jettison Cargo
     * @param {string} shipSymbol 
     * @param {JettisonRequest} [jettisonRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public jettison(shipSymbol: string, jettisonRequest?: JettisonRequest, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).jettison(shipSymbol, jettisonRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Jump your ship instantly to a target system. When used while in orbit or docked to a jump gate waypoint, any ship can use this command. When used elsewhere, jumping requires a jump drive unit and consumes a unit of antimatter (which needs to be in your cargo).
     * @summary Jump Ship
     * @param {string} shipSymbol 
     * @param {JumpShipRequest} [jumpShipRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public jumpShip(shipSymbol: string, jumpShipRequest?: JumpShipRequest, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).jumpShip(shipSymbol, jumpShipRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Navigate to a target destination. The destination must be located within the same system as the ship. Navigating will consume the necessary fuel and supplies from the ship\'s manifest, and will pay out crew wages from the agent\'s account.  The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at it\'s destination.  To travel between systems, see the ship\'s warp or jump actions.
     * @summary Navigate Ship
     * @param {string} shipSymbol The ship symbol
     * @param {NavigateShipRequest} [navigateShipRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public navigateShip(shipSymbol: string, navigateShipRequest?: NavigateShipRequest, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).navigateShip(shipSymbol, navigateShipRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Negotiate Contract
     * @param {string} shipSymbol 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public negotiateContract(shipSymbol: string, body?: any, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).negotiateContract(shipSymbol, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attempt to move your ship into orbit at it\'s current location. The request will only succeed if your ship is capable of moving into orbit at the time of the request.  The endpoint is idempotent - successive calls will succeed even if the ship is already in orbit.
     * @summary Orbit Ship
     * @param {string} shipSymbol The symbol of the ship
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public orbitShip(shipSymbol: string, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).orbitShip(shipSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the nav data of a ship, such as the flight mode.
     * @summary Patch Ship Nav
     * @param {string} shipSymbol The ship symbol
     * @param {PatchShipNavRequest} [patchShipNavRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public patchShipNav(shipSymbol: string, patchShipNavRequest?: PatchShipNavRequest, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).patchShipNav(shipSymbol, patchShipNavRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Purchase cargo.
     * @summary Purchase Cargo
     * @param {string} shipSymbol 
     * @param {PurchaseCargoRequest} [purchaseCargoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public purchaseCargo(shipSymbol: string, purchaseCargoRequest?: PurchaseCargoRequest, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).purchaseCargo(shipSymbol, purchaseCargoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Purchase a ship
     * @summary Purchase Ship
     * @param {PurchaseShipRequest} [purchaseShipRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public purchaseShip(purchaseShipRequest?: PurchaseShipRequest, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).purchaseShip(purchaseShipRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refuel your ship from the local market.
     * @summary Refuel Ship
     * @param {string} shipSymbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public refuelShip(shipSymbol: string, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).refuelShip(shipSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a mount from a ship.
     * @summary Remove Mount
     * @param {string} shipSymbol 
     * @param {RemoveMountRequest} [removeMountRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public removeMount(shipSymbol: string, removeMountRequest?: RemoveMountRequest, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).removeMount(shipSymbol, removeMountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sell cargo.
     * @summary Sell Cargo
     * @param {string} shipSymbol 
     * @param {SellCargoRequest} [sellCargoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public sellCargo(shipSymbol: string, sellCargoRequest?: SellCargoRequest, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).sellCargo(shipSymbol, sellCargoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attempt to refine the raw materials on your ship. The request will only succeed if your ship is capable of refining at the time of the request.
     * @summary Ship Refine
     * @param {string} shipSymbol The symbol of the ship
     * @param {ShipRefineRequest} [shipRefineRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public shipRefine(shipSymbol: string, shipRefineRequest?: ShipRefineRequest, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).shipRefine(shipSymbol, shipRefineRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transfer cargo between ships.
     * @summary Transfer Cargo
     * @param {string} shipSymbol 
     * @param {TransferCargoRequest} [transferCargoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public transferCargo(shipSymbol: string, transferCargoRequest?: TransferCargoRequest, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).transferCargo(shipSymbol, transferCargoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Warp your ship to a target destination in another system. Warping will consume the necessary fuel and supplies from the ship\'s manifest, and will pay out crew wages from the agent\'s account.  The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at it\'s destination.
     * @summary Warp Ship
     * @param {string} shipSymbol 
     * @param {NavigateShipRequest} [navigateShipRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public warpShip(shipSymbol: string, navigateShipRequest?: NavigateShipRequest, options?: AxiosRequestConfig) {
        return FleetApiFp(this.configuration).warpShip(shipSymbol, navigateShipRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemsApi - axios parameter creator
 * @export
 */
export const SystemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get jump gate details for a waypoint.
         * @summary Get Jump Gate
         * @param {string} systemSymbol The system symbol
         * @param {string} waypointSymbol The waypoint symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJumpGate: async (systemSymbol: string, waypointSymbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemSymbol' is not null or undefined
            assertParamExists('getJumpGate', 'systemSymbol', systemSymbol)
            // verify required parameter 'waypointSymbol' is not null or undefined
            assertParamExists('getJumpGate', 'waypointSymbol', waypointSymbol)
            const localVarPath = `/systems/{systemSymbol}/waypoints/{waypointSymbol}/jump-gate`
                .replace(`{${"systemSymbol"}}`, encodeURIComponent(String(systemSymbol)))
                .replace(`{${"waypointSymbol"}}`, encodeURIComponent(String(waypointSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve imports, exports and exchange data from a marketplace. Imports can be sold, exports can be purchased, and exchange goods can be purchased or sold. Send a ship to the waypoint to access trade good prices and recent transactions.
         * @summary Get Market
         * @param {string} systemSymbol The system symbol
         * @param {string} waypointSymbol The waypoint symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarket: async (systemSymbol: string, waypointSymbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemSymbol' is not null or undefined
            assertParamExists('getMarket', 'systemSymbol', systemSymbol)
            // verify required parameter 'waypointSymbol' is not null or undefined
            assertParamExists('getMarket', 'waypointSymbol', waypointSymbol)
            const localVarPath = `/systems/{systemSymbol}/waypoints/{waypointSymbol}/market`
                .replace(`{${"systemSymbol"}}`, encodeURIComponent(String(systemSymbol)))
                .replace(`{${"waypointSymbol"}}`, encodeURIComponent(String(waypointSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the shipyard for a waypoint. Send a ship to the waypoint to access ships that are currently available for purchase and recent transactions.
         * @summary Get Shipyard
         * @param {string} systemSymbol The system symbol
         * @param {string} waypointSymbol The waypoint symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShipyard: async (systemSymbol: string, waypointSymbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemSymbol' is not null or undefined
            assertParamExists('getShipyard', 'systemSymbol', systemSymbol)
            // verify required parameter 'waypointSymbol' is not null or undefined
            assertParamExists('getShipyard', 'waypointSymbol', waypointSymbol)
            const localVarPath = `/systems/{systemSymbol}/waypoints/{waypointSymbol}/shipyard`
                .replace(`{${"systemSymbol"}}`, encodeURIComponent(String(systemSymbol)))
                .replace(`{${"waypointSymbol"}}`, encodeURIComponent(String(waypointSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the details of a system.
         * @summary Get System
         * @param {string} systemSymbol The system symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystem: async (systemSymbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemSymbol' is not null or undefined
            assertParamExists('getSystem', 'systemSymbol', systemSymbol)
            const localVarPath = `/systems/{systemSymbol}`
                .replace(`{${"systemSymbol"}}`, encodeURIComponent(String(systemSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch all of the waypoints for a given system. System must be charted or a ship must be present to return waypoint details.
         * @summary List Waypoints
         * @param {string} systemSymbol The system symbol
         * @param {number} [page] What entry offset to request
         * @param {number} [limit] How many entries to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemWaypoints: async (systemSymbol: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemSymbol' is not null or undefined
            assertParamExists('getSystemWaypoints', 'systemSymbol', systemSymbol)
            const localVarPath = `/systems/{systemSymbol}/waypoints`
                .replace(`{${"systemSymbol"}}`, encodeURIComponent(String(systemSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of all systems.
         * @summary List Systems
         * @param {number} [page] What entry offset to request
         * @param {number} [limit] How many entries to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystems: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/systems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View the details of a waypoint.
         * @summary Get Waypoint
         * @param {string} systemSymbol The system symbol
         * @param {string} waypointSymbol The waypoint symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWaypoint: async (systemSymbol: string, waypointSymbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemSymbol' is not null or undefined
            assertParamExists('getWaypoint', 'systemSymbol', systemSymbol)
            // verify required parameter 'waypointSymbol' is not null or undefined
            assertParamExists('getWaypoint', 'waypointSymbol', waypointSymbol)
            const localVarPath = `/systems/{systemSymbol}/waypoints/{waypointSymbol}`
                .replace(`{${"systemSymbol"}}`, encodeURIComponent(String(systemSymbol)))
                .replace(`{${"waypointSymbol"}}`, encodeURIComponent(String(waypointSymbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AgentToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemsApi - functional programming interface
 * @export
 */
export const SystemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get jump gate details for a waypoint.
         * @summary Get Jump Gate
         * @param {string} systemSymbol The system symbol
         * @param {string} waypointSymbol The waypoint symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJumpGate(systemSymbol: string, waypointSymbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJumpGate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJumpGate(systemSymbol, waypointSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve imports, exports and exchange data from a marketplace. Imports can be sold, exports can be purchased, and exchange goods can be purchased or sold. Send a ship to the waypoint to access trade good prices and recent transactions.
         * @summary Get Market
         * @param {string} systemSymbol The system symbol
         * @param {string} waypointSymbol The waypoint symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarket(systemSymbol: string, waypointSymbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarket200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarket(systemSymbol, waypointSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the shipyard for a waypoint. Send a ship to the waypoint to access ships that are currently available for purchase and recent transactions.
         * @summary Get Shipyard
         * @param {string} systemSymbol The system symbol
         * @param {string} waypointSymbol The waypoint symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShipyard(systemSymbol: string, waypointSymbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetShipyard200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShipyard(systemSymbol, waypointSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the details of a system.
         * @summary Get System
         * @param {string} systemSymbol The system symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystem(systemSymbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSystem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystem(systemSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch all of the waypoints for a given system. System must be charted or a ship must be present to return waypoint details.
         * @summary List Waypoints
         * @param {string} systemSymbol The system symbol
         * @param {number} [page] What entry offset to request
         * @param {number} [limit] How many entries to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemWaypoints(systemSymbol: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSystemWaypoints200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemWaypoints(systemSymbol, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return a list of all systems.
         * @summary List Systems
         * @param {number} [page] What entry offset to request
         * @param {number} [limit] How many entries to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystems(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSystems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystems(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * View the details of a waypoint.
         * @summary Get Waypoint
         * @param {string} systemSymbol The system symbol
         * @param {string} waypointSymbol The waypoint symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWaypoint(systemSymbol: string, waypointSymbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWaypoint200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWaypoint(systemSymbol, waypointSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemsApi - factory interface
 * @export
 */
export const SystemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemsApiFp(configuration)
    return {
        /**
         * Get jump gate details for a waypoint.
         * @summary Get Jump Gate
         * @param {string} systemSymbol The system symbol
         * @param {string} waypointSymbol The waypoint symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJumpGate(systemSymbol: string, waypointSymbol: string, options?: any): AxiosPromise<GetJumpGate200Response> {
            return localVarFp.getJumpGate(systemSymbol, waypointSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve imports, exports and exchange data from a marketplace. Imports can be sold, exports can be purchased, and exchange goods can be purchased or sold. Send a ship to the waypoint to access trade good prices and recent transactions.
         * @summary Get Market
         * @param {string} systemSymbol The system symbol
         * @param {string} waypointSymbol The waypoint symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarket(systemSymbol: string, waypointSymbol: string, options?: any): AxiosPromise<GetMarket200Response> {
            return localVarFp.getMarket(systemSymbol, waypointSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the shipyard for a waypoint. Send a ship to the waypoint to access ships that are currently available for purchase and recent transactions.
         * @summary Get Shipyard
         * @param {string} systemSymbol The system symbol
         * @param {string} waypointSymbol The waypoint symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShipyard(systemSymbol: string, waypointSymbol: string, options?: any): AxiosPromise<GetShipyard200Response> {
            return localVarFp.getShipyard(systemSymbol, waypointSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the details of a system.
         * @summary Get System
         * @param {string} systemSymbol The system symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystem(systemSymbol: string, options?: any): AxiosPromise<GetSystem200Response> {
            return localVarFp.getSystem(systemSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch all of the waypoints for a given system. System must be charted or a ship must be present to return waypoint details.
         * @summary List Waypoints
         * @param {string} systemSymbol The system symbol
         * @param {number} [page] What entry offset to request
         * @param {number} [limit] How many entries to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemWaypoints(systemSymbol: string, page?: number, limit?: number, options?: any): AxiosPromise<GetSystemWaypoints200Response> {
            return localVarFp.getSystemWaypoints(systemSymbol, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of all systems.
         * @summary List Systems
         * @param {number} [page] What entry offset to request
         * @param {number} [limit] How many entries to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystems(page?: number, limit?: number, options?: any): AxiosPromise<GetSystems200Response> {
            return localVarFp.getSystems(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * View the details of a waypoint.
         * @summary Get Waypoint
         * @param {string} systemSymbol The system symbol
         * @param {string} waypointSymbol The waypoint symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWaypoint(systemSymbol: string, waypointSymbol: string, options?: any): AxiosPromise<GetWaypoint200Response> {
            return localVarFp.getWaypoint(systemSymbol, waypointSymbol, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemsApi - object-oriented interface
 * @export
 * @class SystemsApi
 * @extends {BaseAPI}
 */
export class SystemsApi extends BaseAPI {
    /**
     * Get jump gate details for a waypoint.
     * @summary Get Jump Gate
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public getJumpGate(systemSymbol: string, waypointSymbol: string, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).getJumpGate(systemSymbol, waypointSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve imports, exports and exchange data from a marketplace. Imports can be sold, exports can be purchased, and exchange goods can be purchased or sold. Send a ship to the waypoint to access trade good prices and recent transactions.
     * @summary Get Market
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public getMarket(systemSymbol: string, waypointSymbol: string, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).getMarket(systemSymbol, waypointSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the shipyard for a waypoint. Send a ship to the waypoint to access ships that are currently available for purchase and recent transactions.
     * @summary Get Shipyard
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public getShipyard(systemSymbol: string, waypointSymbol: string, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).getShipyard(systemSymbol, waypointSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the details of a system.
     * @summary Get System
     * @param {string} systemSymbol The system symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public getSystem(systemSymbol: string, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).getSystem(systemSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch all of the waypoints for a given system. System must be charted or a ship must be present to return waypoint details.
     * @summary List Waypoints
     * @param {string} systemSymbol The system symbol
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public getSystemWaypoints(systemSymbol: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).getSystemWaypoints(systemSymbol, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of all systems.
     * @summary List Systems
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public getSystems(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).getSystems(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View the details of a waypoint.
     * @summary Get Waypoint
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public getWaypoint(systemSymbol: string, waypointSymbol: string, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).getWaypoint(systemSymbol, waypointSymbol, options).then((request) => request(this.axios, this.basePath));
    }
}


